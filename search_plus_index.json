{"./":{"url":"./","title":"XSystem","keywords":"","body":"XSystem 自2017年毕业后至今已工作两年有余，是该把自己的成长点滴做些记录人生路很长，是一本厚书，此书很大，取名XSystem，致敬逝去的青春和时间 个人能力有限，如有纰漏，望各位看官批评指正。 其中可能会有引用的地方，如有侵权，请联系我删除，联系movetobe@outlook.com 2019.12.10于上海 Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2019-12-15 07:51:09 "},"computer_system/computer_sys.html":{"url":"computer_system/computer_sys.html","title":"计算机系统","keywords":"","body":"记录总结成长过程中的计算机技术知识 Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 16:18:06 "},"computer_system/data_structure_and_algorithms/algorithms.html":{"url":"computer_system/data_structure_and_algorithms/algorithms.html","title":"数据结构与算法","keywords":"","body":"常见的数据结构与算法知识整理 主要是：数组/字符串/栈/队列/二叉树/图搜索等相关的数据结构下算法的记录 参考代码 Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 17:28:23 "},"computer_system/data_structure_and_algorithms/double_pointers/double_pointers.html":{"url":"computer_system/data_structure_and_algorithms/double_pointers/double_pointers.html","title":"双指针","keywords":"","body":"一、双指针 双指针是指使用两个指针对线性数据结构进行遍历/搜索的方法。 双指针方法包括： 首尾指针 快慢指针 前后指针 二、双指针方法解析 首尾指针 首指针从线性表从前往后遍历，尾指针从线性表尾部往前遍历。 [剑指offer-57] 和为s的数字 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得他们的和正好是s。 如果有多对数字的和等于s，则输出任意一对即可。 如：输入数组[1, 2, 4, 7, 11, 15]和数字15，由于4 + 11 = 15，则输出[4, 11]即可 采用首尾指针的双指针方法，如图所示： 若nums[front] + nums[tail] 若nums[front] + nums[tail] > s，则说明nums[tail]太大了，需要减小，故tail--; 若nums[front] + nums[tail] == s，得到解； 结束条件front >= tail，无解 int target_sum(int *nums, int nums_size, int target, int *ret_array) { int front = 0; int tail = nums_size - 1; if ((!nums) || (!ret_array) || (nums_size target) { /* decrease left part */ tail--; } } return (front 对于上述方法，由于最多遍历整个数组的所有元素，故时间复杂度是O(n)。如果数组是没有排序的，且可以改变数组，则可以先qsort()排序，然后再用首尾指针。同理，对于三数之和的题目[leetcode-15], 就可以排序，然后固定一个数，然后就是上述的两数之和了，这样的话，可以在O(n^2) 的时间复杂度内解决。 前后指针 前指针先走k步，然后前后指针同步往后遍历。 [剑指offer-22] 链表中倒数第k个节点 输入一个链表，输出该链表中倒数第k个节点。如1->2->3->4->5->6，则倒数第3个节点 就是4所在的节点。 采用前后指针方法，如图所示： 前指针先走k步 前后指针一起走，直到前指针走到NULL 此时后指针指向的节点就是链表的倒数第k个节点 注意：如果链表长度小于k，该如何处理 struct list_node *find_last_kth_node(struct list_node *head, int k) { int step = 0; struct list_node *before = head; struct list_node *after = head; /* before pointer move k step */ for (step = 0; step next; } /* list length next; after = after->next; } return after; } 从前指针的角度看，前指针从链表头遍历一遍到链表尾，故时间复杂度为O(n)。类似的题目如删除链表倒数第N个节点[leetcode-19]，需要注意的是，删除节点需要另外考虑头节点/中间节点/尾节点删除之后，节点之间指针的变化。 快慢指针 顾名思义，就是双指针中一个指针快一个指针慢，通常都是让快指针一次走2步，慢指针一次走1步。 [剑指offer-23] 链表中环的入口节点 如果链表中包含环，如何找出环的入口节点？如图所示，环的入口点为4的节点。 此问题分为如何判断是否有环？和有环的情况下，如何得到环的入口点。两个子问题。 如何判断有环？这里就要使用快慢指针。我们想象，两个同学以不同的速度，同时从教室跑到操场， 然后开始绕操场跑圈。如果操场是直线的操场，那么跑得快的永远都在前面，直到尽头。如果操场是圆圈的操场，那么跑得慢的同学和跑得快的同学总会相遇，而且肯定是在操场上相遇。回到题目中，我们就可以这样来判断链表中是否有环： 快指针一次走2步，慢指针一次走1步，两个同时从头指针处开始走 如果快指针走到了NULL，那说明没有环 如果快指针与慢指针再次相遇了，说明存在环 struct list_node *list_contain_circle(struct list_node *head) { struct list_node *fast = head; struct list_node *slow = head; /* fast move 2 step each time, slow move 1 step each time */ for (;;) { /* fast pointer will goto NULL, no circle */ if ((fast->next == NULL) || (fast->next->next == NULL)) { return NULL; } fast = fast->next->next; slow = slow->next; /* fast pointer equal to slow, circle * put check after fast and slow update, as fast and slow are both * initialized to head, this is their meet again. */ if (fast == slow) { return fast; } } } 如何得到环的入口点前面我们判断出链表是否存在环，假如存在环，且环的大小是n。那么我们通过前后指针， 让前指针先走n步，然后前后指针一起走，当前后指针相遇的时候就是环的入口点。 这里可以这样理解，你和同学从教室跑去绕操场，你同学一直在领先你一圈的位置。 那么，当你跑到操场入口的时候，你同学在你前面一圈的位置，也就是刚好也在操场入口。 求出环的长度n，只需要从环上一点，开始循环计数，直到回到原点，即得环长度 前指针走n步，前后指针一起走，直到前后指针重叠 返回此时前后指针的节点，即为环的入口点 /* node in the circle can be get from the list_contain_circle interface. */ int list_circle_length(struct list_node *circle_node) { int circle_len = 0; struct list_node *curr = circle_node->next; while (curr != circle_node) { circle_len++; curr = curr->next; } return circle_len + 1; } struct list_node *list_circle_entry(struct list_node *head) { struct list_node *before = head; struct list_node *after = head; struct list_node *node_in_circle = list_contain_circle(head); int circle_len = 0; int step = 0; if (!node_in_circle) { return NULL; } circle_len = list_circle_length(node_in_circle); /* before pointer move circle_len step */ for (step = 0; step next; } /* move together */ while (before != after) { before = before->next; after = after->next; } return before; } 可以看到，在判断是否有环时遍历了一遍链表，在计算环长度遍历了环， 最后查找入口节点时最多可能遍历一边链表。因此，时间复杂度在O(n)量级。 三、总结 在数组中使用双指针，通常需要是排序的数组，因此，对没有排序的数组可以先对数组进行排序。 如前面提到的三数之和的题目[leetcode-15]。数组中双指针进一步可能拓展到多指针，如leetcode-632 最小区间问题。双指针也会用在字符串中，如leetcode-76最小覆盖字串。 Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2019-12-31 22:58:07 "},"computer_system/data_structure_and_algorithms/recursive/recursive.html":{"url":"computer_system/data_structure_and_algorithms/recursive/recursive.html","title":"递归/回溯","keywords":"","body":"一、递归 递归通常用在可以把一个问题分解成子问题求解，最终由子问题的解可以合成问题的解。举个例子来理解递归，假如问题的解是[a0, a1, a2, ..., an]，那么用递归求解就是： 求解[a0]和[a1, a2, ..., an]； 求解[a1]和[a2, a3, ..., an]; ... 直到求解出[an]，最后由[a0], [a1], ..., [an]得到最终解。 递归方法优缺点明显。优点： 逻辑清晰，代码简洁。 缺点： 递归层次较深时，函数调用多，性能较差。 递归过程中会重复求解相同的子问题，性能较差。 递归实质上是利用了系统栈的空间，如果层次较深，容易产生栈溢出。 当然，对于重复子问题，可以通过申请一定的空间保存已经计算出来的子问题，从而提高性能。 二、递归应用 递归在线性数据结构、树、图都有应用，涵盖较广。递归应用中通常伴随回溯，当然有时候是不需要回溯的。递归思想上可以用三板斧来思考： 递归结束的条件。 子问题求解。 子问题求解完毕，是否需要回溯。 在实际求解中，可以转换成如下三步： 递归结束的条件。 options，广度上从哪里更进一步？递归函数参数总需要有一个index，来表示走到哪一步？ 是否需要回溯。 线性数据结构中的递归应用 [leetcode-46] 全排队 给定一个没有重复数字的序列，返回其所有可能的全排列。输入: [1,2,3]输出: [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 首先分析题目，全排列数组，就是每次确定一个数，直到最后一个。如上图所示，第一个数可以选择1/2/3中的一个，第二个可以选择剩下的两个中的一个，最后就是剩下的那一个。按上述递归/回溯的思路： 递归结束的条件：最后一个数找到 options，确定这个数有哪些选择？那就是剩下的数里面选一个，然后继续下一个数的选择 回溯，把上次选的数放回去，重新来选 void permute(int *nums, int nums_size, int index, int **return_array, int *return_size) { int i = 0; /* index indicates which step we arrived, ended position: final element */ if (index == nums_size) { return_array[*return_size] = calloc(1, sizeof(int) * nums_size); memcpy(return_array[*return_size], nums, sizeof(int) * nums_size); *return_size = *return_size + 1; return; } /* options: in permutations, what options does current \"index\" can be ? */ for (i = index; i 线性数据结构中使用递归/回溯，如[剑指offer-38]字符串的排列，即输入一个字符串， 输出字符串的所有排列。只是将上述题目中的数字换成字符。还有的题目需要增加每一步是否合法的判断，如[leetcode-47] 数字全排列，需要考虑重复排列，这个就可以对数组先排序，如果current \"index\"跟上一个\"index\"的值一样， 那么意味着重复，需要排除，即在递归前多一个判断这一步是否要走。 [leetcode-22]括号生成， 也是需要增加合法性的判断，即对左括号和右括号个数的判断。 树中的递归应用 树型结构是递归天然的战场。对于树型结构的问题，通常都转化为求解其子树的问题。 树型结构里最经典的就是二叉树，下面我们就以二叉树为例子说明递归/回溯在树型结构中的应用。树型结构递归/回溯常见思路： 递归结束条件：到达叶子节点 options: 左子树和右子树，对于二叉树就这两种选择 回溯，是否需要回溯到父节点 [二叉树的前序/中序/后序遍历] 前序遍历 void preorder(struct tree_node *root) { if (!root) { return; } visit(root->data); preorder(root->left); preorder(root->right); } 中序遍历 void inorder(struct tree_node *root) { if (!root) { return; } inorder(root->left); visit(root->data); inorder(root->right); } 后序遍历 void postorder(struct tree_node *root) { if (!root) { return; } postorder(root->left); postorder(root->right); visit(root->data); } 几乎所有的二叉树的题目都是遍历树，那么就是前序/中序/后序遍历的变形。 图中的递归应用 在图的题目中，最常用的搜索方法就是深度优先搜索(DFS)和广度优先搜索(BFS)。其中， DFS使用递归/回溯方法实现，使得逻辑清晰，代码简洁。 [leetcode-79] 单词搜索 给定一个二维网格和一个单词，找出该单词是否存在于网格中。方向可以上下左右搜素， 网格字符不能重复 仍然是按照前面的三步走： 结束条件：搜索的单词完成了。 options：判断当前字符满足条件，往上下左右走一步。 回溯：上下左右均没有满足，该字符放弃。 int compare_word(char **board, int row, int col, int x, int y, char *word, int index, int **visited) { /* ended position: index is last one */ if (index == (strlen(word))) { return 1; } /* options */ if ((x >= 0) && (x = 0) && (y 三、总结 解题三步走： 结束条件 options：往哪个方向走？ 是否需要回溯？ 子问题优化： 空间换时间，额外空间缓存已经求解的子问题 最后以优化的递归来结束递归/回溯章节 [leetcode-403] 青蛙过河 一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。输入：[0,1,3,5,6,8,12,17]输出：true解释： 总共有8个石子。第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,第三个石子在序号为3的单元格的位置， 以此定义整个数组...最后一个石子处于序号为17的单元格的位置。青蛙可以成功过河：跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着跳2个单位到第4块石子, 然后跳3个单位到第6块石子,跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。 按前面叙述的几个步骤： 结束条件：跳到了最后一个石子 options：跳 k - 1, k, k + 1 三种可能性 不需要回溯，找到就说明存在，没找到就是不存在 优化 如图所示，假设青蛙从index跳k步到next_index，那么只要判断从next_index开始，经过k - 1, k, k + 1步能否到达终点。如果青蛙从index跳k步到达不了next_index，那么到达不了。 重复子问题的优化，只需要用一个二维数组，保存从index跳k步能否到达终点。如果从index跳k步的子问题已经求解过了，则直接返回。否则需要递归求解，求解的结果保存在数组中。 /* cross(stones, stonesSize, 0, 1, cross_hist) */ int cross(int *stones, int stones_size, int index, int step, int **cross_hist) { int stone = stones[index] + step; int next_index = 0; /* ended position: step to last one */ if (stone == stones[stones_size - 1]) { return CROSS_YES; } /* optimize: had been solved */ if (cross_hist[index][step] > CROSS_NONE) { return cross_hist[index][step]; } /* next stone's position, -1 means cannot cross */ next_index = next(stones, stones_size, stone, index); if (next_index Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2020-03-08 23:59:15 "},"computer_system/data_structure_and_algorithms/dynamic_programming/dynamic_programming.html":{"url":"computer_system/data_structure_and_algorithms/dynamic_programming/dynamic_programming.html","title":"动态规划","keywords":"","body":"一、动态规划 对于可以分解成最优子问题的题目，通常可以采用递归求解。而递归一个明显的缺点就是需要求解重复的子问题。对于重复子问题，我们在递归章节采用了缓存的方法来规避。其实，将递归方法采用循环方式实现，加上子问题的缓存，就是动态规划。 二、动态规划应用 动态规划通常用在求解最值问题，如最大值/最小值问题。比较常见的问题在字符串和图中的求解。 字符串中的动态规划 解决两个字符串的动态规划问题，通常可以用两个指针分别指向字符串的最后，然后一步步往前走，缩小问题规模。 最为经典的字符串题目就是求解两个字符串的最长公共子序列。 [leetcode-1143] 最长公共子序列 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，\"ace\" 是 \"abcde\" 的子序列，但 \"aec\" 不是 \"abcde\" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。 类似于数学归纳法的分析方法。我们先讨论字符串text1text1text1从text1[0]→text1[i−1]text1[0] \\rightarrow text1[i - 1]text1[0]→text1[i−1]和字符串text2text2text2从text2[0]→text2[j−1]text2[0] \\rightarrow text2[j - 1]text2[0]→text2[j−1]的最长公共子序列。假设它们的最长公共子序列长度是lcs[i−1][j−1]lcs[i - 1][j - 1]lcs[i−1][j−1]，则我们用归纳法，text1text1text1和text2text2text2都增加一个字符text1[i]text1[i]text1[i]和text2[j]text2[j]text2[j]： 如果text1[i]==text2[j]text1[i] == text2[j]text1[i]==text2[j]，那么lcs[i][j]=lcs[i−1][j−1]+1lcs[i][j] = lcs[i - 1][j- 1] + 1lcs[i][j]=lcs[i−1][j−1]+1 如果text1[i]!=text2[j]text1[i] != text2[j]text1[i]!=text2[j], 则text1[i]text1[i]text1[i]和text2[j]text2[j]text2[j]不可能同时为最长公共子串的字符，只能选择一个作为最长公共子串的字符： 如果text1[i]text1[i]text1[i]作为最长公共子串的一个字符，则lcs[i][j]=lcs[i][j−1]lcs[i][j] = lcs[i][j - 1]lcs[i][j]=lcs[i][j−1] 如果text2[j]text2[j]text2[j]作为最长公共子串的一个字符，则lcs[i][j]=lcs[i−1][j]lcs[i][j] = lcs[i - 1][j]lcs[i][j]=lcs[i−1][j] 那么text1[i]text1[i]text1[i]和text2[j]text2[j]text2[j]选取哪个作为最长公共子串的字符呢？既然我们要找的是最长的，那么对于lcs[i][j−1]lcs[i][j - 1]lcs[i][j−1]和lcs[i−1][j]lcs[i - 1][j]lcs[i−1][j]，我们当然是哪一个大就选哪一个。因此，就得到了最长公共子序列的数学表达式： lcs[i][j]={lcs[i−1][j−1]+1text1[i]==text2[j]max{lcs[i][j−1],lcs[i−1][j]}text1[i]!=text2[j] lcs[i][j] = \\left\\{ \\begin{aligned} & lcs[i - 1][j - 1] + 1 &{text1[i] == text2[j]}\\\\ & max\\{lcs[i][j - 1], lcs[i - 1][j]\\} &{text1[i] != text2[j]} \\end{aligned} \\right. lcs[i][j]={​​​​​lcs[i−1][j−1]+1​max{lcs[i][j−1],lcs[i−1][j]}​​​text1[i]==text2[j]​text1[i]!=text2[j]​​ 为了实现方便，动态规划二维数组下标可以从 1 开始 动态规划还有很重要的一点就是对数据的初始化，因为上述的递推关系，最后都要落到i==0i == 0i==0或者j==0j == 0j==0。通常对于有限的条件下，我们是可以比较容易的得到相应的数据。如上述lcs[i][j]lcs[i][j]lcs[i][j]，当i==0i == 0i==0或者j==0j == 0j==0时，意味着text1text1text1或者text2text2text2为空，那么它们的最长公共子串长度当然是0，即: lcs[0][0] = 0; for (i = 1; i 然后就是对前述递推表达式的实现： for (i = 1; i lcs[i][j - 1] ? lcs[i - 1][j] : lcs[i][j - 1]); } } } 最后只需要取i==strlen(text1)&&j==strlen(text2)i == strlen(text1) \\&\\& j == strlen(text2)i==strlen(text1)&&j==strlen(text2)时的lcs[i][j]lcs[i][j]lcs[i][j]即是text1text1text1和text2text2text2的最长公共子序列的长度值。 int longest_common_subsequence(char *text1, char *text2) { int len1 = strlen(text1); int len2 = strlen(text2); int i, j, longest; int **lcs = calloc(1, sizeof(int *) * (len1 + 1)); for (i = 0; i lcs[i][j - 1] ? lcs[i - 1][j] : lcs[i][j - 1]); } } } longest = lcs[len1][len2]; for (i = 0; i 图中的动态规划 图一般通过二维数组表示，如果其求解的最值问题是单方向增长的，就可以比较容易地想到使用动态规划求解。什么叫做单方向增长呢？比如说，网格上找路径，如果寻找方向只能从左上角->右下角搜索，那么这里就称为单方向增长。如果寻找方向可以上下左右搜索，那么更加适合递归地去搜索。如下面的最短路径和，就是典型的图中动态规划的题目，它的增长方向就是从左上角到右下角。 [leetcode-64]最短路径和 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。如，输入:1,3,11,5,14,2,1输出: 7解释: 因为路径 1->3->1->1->1 的总和最小。 分析方法跟字符串中动态规划的分析方法类似，采用归纳法：假设当前走到了网格中的grid[i][j]grid[i][j]grid[i][j]节点，此时路径上的数字总和最小为ps[i][j]ps[i][j]ps[i][j]，那么： 走到grid[i−1][j]grid[i - 1][j]grid[i−1][j]时，数字总和最小为ps[i−1][j]ps[i - 1][j]ps[i−1][j] 走到grid[i][j−1]grid[i][j - 1]grid[i][j−1]时，数字总和最小为ps[i][j−1]ps[i][j - 1]ps[i][j−1] 显然，因为每个节点只能从两个方向过来，故：ps[i][j]=min{ps[i−1][j],ps[i][j−1]}ps[i][j] = min\\{ps[i - 1][j], ps[i][j - 1]\\}ps[i][j]=min{ps[i−1][j],ps[i][j−1]} 初始化过程： 同样对于i==0i == 0i==0或者j==0j == 0j==0需要做数据初始化。当i==0i == 0i==0或者j==0j == 0j==0时，只有一条路，就是要么向右直走，要么向下直走。故ps[i][0]ps[i][0]ps[i][0]或者ps[0][j]ps[0][j]ps[0][j]初始值就是它们一路的路径之和，即: ps[0][0] = grid[0][0]; for (i = 1; i 然后按上述递推式，完成所有数据： for (i = 1; i 最后所要求取的，就是走到右下角，即ps[i][j]ps[i][j]ps[i][j]的右下角的值。 /* ps[i][j] = min{ps[i - 1][j], p[i][j - 1]} + grid[i][j] */ int min_path_sum(int **grid, int gridSize, int *gridColSize) { int i, j, min_sum; int **ps = calloc(1, sizeof(int *) * gridSize); for (i = 0; i 三、总结 动态规划解答通常分为3步： 递归表达式 初始化数据 循环求解数据 最难的就是递归表达式的描述了。 Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2020-01-29 10:34:30 "},"computer_system/data_structure_and_algorithms/mono_stack/mono_stack.html":{"url":"computer_system/data_structure_and_algorithms/mono_stack/mono_stack.html","title":"单调栈","keywords":"","body":"一、什么是单调栈 单调栈是指栈中的数据按递增/递减顺序存放。故单调栈通常分为单调递增栈和单调递减栈。 单调递增栈： 栈中元素按递增顺序存放，通常用于求解数组中比当前元素小的下一个/前一个元素。单调递减栈： 栈中元素按递减顺序存放，通常用于求解数组中比当前元素大的下一个/前一个元素。 二、单调栈的应用 单调栈通常应用在数组中，应用中对于数组中每个元素，核心步骤为(以单调递减栈为例)： 栈非空，当前元素比栈顶大，弹出栈顶元素，开始处理数据。一直弹栈处理，直到栈空，或者比栈顶小。 压栈 (满足单调递减特性) [leetcode-739] 每日温度 根据每日气温列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。如：输入：[73, 74, 75, 71, 69, 72, 76, 73]输出：[1, 1, 4, 2, 1, 1, 0, 0]提示：气温列表长度的范围是 [1, 30000]。气温的值均为华氏度，都是在 [30, 100] 范围内的整数。 如果采用直接求解，则对每个温度，遍历其后的每个元素，判断是否超过该日温度。这样求解的时间复杂度为O(n^2)。这个题目是典型的单调栈的应用，可以在O(n)时间复杂度内求解，不过对应的需要O(n)的空间复杂度。可以采用单调递减栈，对于每日温度，核心步骤为： 栈非空，该日温度比栈顶对应温度大，找到超过栈顶对应温度的第一个温度，弹栈，处理数据。一直弹栈处理，直到栈空，或者该日温度比栈顶对应温度小。 压栈 (栈中温度单调递减，都还没找到比自身大的温度) /* Note: The returned array must be malloced, assume caller calls free(). */ int *dailyTemperatures(int *T, int TSize, int *returnSize) { int *days = calloc(1, sizeof(int) * TSize); int i = 0; struct stack s; int top_day = 0; stack_init(&s); for (i = 0; i top, just pop until current element T[touch_pop(&s)])) { top_day = pop(&s); days[top_day] = i - top_day; } /* push, keep decrease stack */ push(&s, i); } while (!stack_empty(&s)) { days[pop(&s)] = 0; } *returnSize = TSize; return days; } [leetcode-42]接雨水 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,3,1] 表示的高度图，在这种情况下，可以接8个单位的雨水（蓝色部分表示雨水），如：输入: [0,1,0,2,1,0,1,3,2,1,3,1]输出: 8 这个题目也是用单调递减栈来求解，这里为了计算面积的方便，栈中保存的是对应柱子的下标。 可以先只考虑只有一个接雨水的地方，如图中的b->c->d->e之间，那么，从b开始，对于递减的数压栈，则c和B对应的下标相继压栈。接着，碰到比栈顶大的数d，就出现了积水的地方B。此时积水的高度是c和d的低者和栈顶B对应数的差值，而宽度就是d和B下标的差值。因此，我们会弹出栈顶B对应的数，然后去计算积水B，然后d压栈。接着继续e的一系列动作。对于题目中给出的例子，在图中给出了完整的 { 弹(栈)/取(栈顶值)/算/压(栈) } 四个步骤的的过程。 int trap(int *height, int heightSize) { int i = 0; struct stack s; int area = 0; int bottom = 0; int top = 0; int idx_prev = 0; /* decrease stack */ stack_init(&s); for (i = 0; i height[touch_pop(&s)])) { /* pop */ bottom = height[pop(&s)]; if (!stack_empty(&s)) { /* touch top of stack */ idx_prev = touch_pop(&s); top = height[i] 三、总结 单调递减栈： 碰到比栈顶小，压栈；碰到比栈顶大的，弹栈处理。单调递增栈： 碰到比栈顶大，压栈；碰到比栈顶小的，弹栈处理。压栈的元素，可能直接是当前处理的数，也可能是下标。基本上可以用如下框架来完成单调栈(单调递减栈为例)： for (i = 0; i top_of_stack) { pop(); ... } push(); } 一般单调栈的应用需要一定的转换，如[leetcode-1124]表现良好的最长时间段，就是通过转换成前缀和数组后，最后求解前缀和数组的最长上坡。 Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2020-01-09 22:21:08 "},"computer_system/data_structure_and_algorithms/tree/tree.html":{"url":"computer_system/data_structure_and_algorithms/tree/tree.html","title":"二叉树","keywords":"","body":"一、二叉树 一直以为树比较简单，因为都是按照左子树/右子树递归来解决问题。但是\b这两天做了leetcode竞赛，其中关于二叉树的题目，不算难，也是按照左子树/右子树递归来解决，但是，在应用实现中，还是有值得思考的地方。 [leetcode-5346]二叉树中的列表 给你一棵以 root 为根的二叉树和一个 head 为第一个节点的链表。 如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 head 为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。 一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。 /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ 根据题目简要分析： 如果head->val == root->val，则只需要判断head->next为首的链表是否存在于root->left为根的左子树或者以root->right为根的右子树中。 否则只需判断head链表是否存在root->left或者root->right的子树中 很容易就可以得到如下简洁清晰的代码： int is_sub_path(struct ListNode* head, struct TreeNode* root){ /* end */ if (!head) { return 1; } if (!root) { return 0; } /* options */ if (head->val == root->val) { if (isSubPath(head->next, root->left) || isSubPath(head->next, root->right)) { return 1; } } if (isSubPath(head, root->left)) { return 1; } if (isSubPath(head, root->right)) { return 1; } return 0; } 很不幸的是，上面代码在leetcode上会超时。如果换一种写法，就能通过。 int sub_path(struct ListNode* head, struct TreeNode* root){ /* end */ if (!head) { return 1; } if (!root) { return 0; } if (head->val != root->val) { return 0; } /* options */ return (sub_path(head->next, root->left) || sub_path(head->next, root->right)); } int is_sub_path(struct ListNode* head, struct TreeNode* root){ /* end */ if (!head) { return 1; } if (!root) { return 0; } /* options */ return (sub_path(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right)); } 惭愧，至写此文时，还没能很好的分析出第二种写法性能好的原因。 [leetcode-1339]分裂二叉树的最大乘积 给你一棵二叉树，它的根为 root 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。 由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。 分为以root'为根的子树，与root树其他部分 root'为根的子树和，递归求解左子树和右子树+root'->val 求解以root'为根的子树与其余部分的乘积 左子树和右子树在递归求解子树和时，对任何一个root''，均会做这三步 这样求解，就从叶子到根，求解以任何一个节点为根的树，与其余部分的乘积 #define MAX(a, b) ((a) > (b) ? (a) : (b)) #define M 1000000007 long sum(struct TreeNode *root) { if (!root) { return 0; } return (root->val + sum(root->left) + sum(root->right)); } long cut(struct TreeNode *root, long *product, long total) { long current_sum; if (!root) { return 0; } current_sum = root->val + cut(root->left, product, total) + cut(root->right, product, total); *product = MAX(*product, (total - current_sum)* current_sum); return current_sum; } int max_product(struct TreeNode* root) { long product = 0; cut(root, &product, sum(root)); return product % M; } Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 16:12:26 "},"computer_system/data_structure_and_algorithms/graph/graph.html":{"url":"computer_system/data_structure_and_algorithms/graph/graph.html","title":"图","keywords":"","body":"一、图搜索 广度优先搜索 层级搜索，故适合求解类似于最短路径/最少等问题。基本方法： 起点入队列 遍历队列，如果需要在最短路径情况的解，需要按层\b遍历，层的\b宽度通过获取当前队列的长度的决定 对该层的所有点，判断其四个方向点是否满足条件，可以入队列 循环2-3步 通常会定义一个cost[i][j]来存储到达(i, j)时的最少消耗/最大\b收益，需要仔细判断什么时候能够更新这个cost[i][j]值，同时将该点入队列 广度优先搜索因为每搜索到一层，就是从\b\b起点到当前层的最短路径，故天然地适合去解决最短路径上问题。很适合去求解路径上需要消除障碍物或者路径上获取最大价值之类的问题。 [leetcode-1293] 网格中的最短路径 给你一个 m x n 的网格，其中每个单元格不是 0（空）就是 1（障碍物）。每一步，您都可以在空白单元格中上、下、左、右移动。如果您 最多 可以消除 k 个障碍物，请找出从左上角 (0, 0) 到右下角 (m-1, n-1) 的最短路径，并返回通过该路径所需的步数。如果找不到这样的路径，则返回 -1。如：输入：grid =[[0,0,0], [1,1,0], [0,0,0], [0,1,1], [0,0,0]],k = 1输出：6 要找最多消除k个障碍物到达目的地 要求最短路径 故采用广度优先搜索，按层\b遍历，每次找到可以往下走的点。 cost[][]保存每个单元格消除障碍物的数量，什么时候能够更新呢？ 当从其他路径可以用消除更少的障碍物，而到达该单元格时需要更新单元格的cost 两种更新场景，更新代表找到了更优的解，需要将当前解入队列： 该单元格有障碍物，cost需要加1 该单元格无障碍物，cost无需增加，就是到达上个节点的cost int cross_obstacles(int **matrix, struct position *start, struct position *end, int k) { int row = end->x + 1, col = end->y + 1; int **cost = calloc(1, sizeof(int *) * row); int **visited = calloc(1, sizeof(int *) * row); int i, j; struct position current, next; struct queue *q = init_queue(); int level_size; struct position directions[] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}}; int path_len = 0;; int find = 0; for (i = 0; i x][start->y] = 1; cost[start->x][start->y] = 0; while (queue_size(q) > 0) { level_size = queue_size(q); path_len++; for (i = 0; i x && current.y == end->y) { find = 1; break; } for (j = 0; j = row) || (next.y = col)) { continue; } /* next is not an obstacles */ if ((matrix[next.x][next.y] == 0) && (cost[next.x][next.y] > cost[current.x][current.y])) { cost[next.x][next.y] = cost[current.x][current.y]; if (!visited[next.x][next.y]) { enqueue(q, &next); visited[next.x][next.y] = 1; } } /* next is an obstacles */ if (matrix[next.x][next.y] && (cost[current.x][current.y] + 1 cost[current.x][current.y] + 1)) { /* next cost is greater than from current->next */ cost[next.x][next.y] = cost[current.x][current.y] + 1; if (!visited[next.x][next.y]) { enqueue(q, &next); visited[next.x][next.y] = 1; } } } } if (find) { break; } } for (i = 0; i 类似的题目如[leetcode-5347] 使网格图至少有一条有效路径的最小代价, 此时，由于\b\b只需要有效路径，故只需要能让cost\b变小的路径就应该更新cost。 /* d[i][j] -> d[i + dx][j + dy] update everytime if the value less. */ int min_cost(int **grid, int grid_size, int *grid_col_size) { int i, j; int **cost = calloc(1, sizeof(int *) * gridSize); int **visited = calloc(1, sizeof(int *) * gridSize); struct queue *q = init_queue(); struct position pos = {0, 0}, next; struct position direct[] = {{0, 0}, {0, 1}, {0, -1}, {1, 0}, {-1, 0}}; int m; for (i = 0; i = gridSize) || (pos.y + direct[i].y = gridColSize[0])) { continue; } next.x = pos.x + direct[i].x; next.y = pos.y + direct[i].y; if ((grid[pos.x][pos.y] == i) && (cost[pos.x][pos.y] 深度优先搜索 二、拓扑排序 实际上，拓扑排序可以看作是 拓扑排序的基本方法： 从图中选取所有入度为0的点，\b入队列 出队列取值，得到入度为0的点A 遍历所有节点，如果节点的入度为A，删除该节点的入边A，如果删除之后入度为0，则入队列 循环处理2-3，直到所有都处理完，即队列为空 基本框架： void topological_sort(int **graph, int *ingree, int num, int *path) { int i = 0, j = 0; int current; struct queue *q = init_queue(); /* all nodes that ingree == 0 enqueue. */ for (j = 0; j Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 16:12:57 "},"computer_system/leetcode/leetcode.html":{"url":"computer_system/leetcode/leetcode.html","title":"leetcode","keywords":"","body":"参与leetcode活动的相关记录 主要是leetcode每日一题活动/leetcode周竞赛等活动 参考代码 Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 17:26:22 "},"computer_system/leetcode/leetcode_everyday/202003.html":{"url":"computer_system/leetcode/leetcode_everyday/202003.html","title":"每日一题-2020/03","keywords":"","body":"2020/03/07 [面试题59 - II. 队列的最大值] 请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的时间复杂度都是O(1)。若队列为空，pop_front 和 max_value 需要返回 -1 有类似的题目是，如何在O(1)时间内获取栈的最小值。类似的思想，采用两个队列，一个存储原始数据，一个存储可能成为下一个最大值的数据，辅助队列为单调递减队列(即保持从front->rear的数据递减)。为什么要保持递减？ 当新来的数据比前面的数据大，毫无疑问，那些比它小的数据都没有用处了。因为在它们出队列之前，最大值永远都是刚来的这个数。 当新来的数据比前面数据小，那么前面的数据都出队列之后，它是有可能成为最大值的。 例子：[3, 4, 4, 3, 5]，主队列A，辅助队列B A: [3], B: [3] A: [3, 4], B: [4] /* B保持从front->rear递减，故3被去掉，4入队列 */ A: [3, 4, 4], B: [4, 4] /* 为判断B何时出队列，B非严格单调递减队列 */ A: [3, 4, 4, 3], B: [4, 4, 3] /* 直接入队列，因为能保持递减 */ A: [3, 4, 4, 3], B: [5] 获取队列最大值就直接从辅助队列的front取值。出队列的时候，如果出队列的值与辅助队列的front位置值相等，辅助队列也要出队列。 具体实现: (push的时候不是O(1)复杂度) struct max_queue { int value[QUEUE_LEN]; int front; int rear; int max_value[QUEUE_LEN]; int max_front; int max_rear; }; int get_queue_max_value(struct max_queue *obj) { return (queue_empty(obj) ? -1 : obj->max_value[obj->max_front]); } void enqueue(struct max_queue *obj, int value) { /* while max_value not empty, keep queue decrease */ while (obj->max_front != obj->max_rear) { obj->max_rear = (obj->max_rear + QUEUE_LEN - 1) % QUEUE_LEN; if (value max_value[obj->max_rear]) { obj->max_rear = (obj->max_rear + 1) % QUEUE_LEN; break; } } obj->max_value[obj->max_rear] = value; obj->max_rear = (obj->max_rear + 1) % QUEUE_LEN; obj->value[obj->rear] = value; obj->rear = (obj->rear + 1) % QUEUE_LEN; } int dequeue(struct max_queue *obj) { int value; if (queue_empty(obj)) { return -1; } value = obj->value[obj->front]; obj->front = (obj->front + 1) % QUEUE_LEN; if (value == obj->max_value[obj->max_front]) { obj->max_front = (obj->max_front + 1) % QUEUE_LEN; } return value; } 2020/03/08 [322. 零钱兑换] 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 常规的深度优先搜索： 明确递减的方向，即amount的值 由于性能问题，需要用cache保存已经计算了的子问题，该子问题就是amount值对应的最少硬币数，即cache[amount]. #define MIN(a, b) ((a) = 0) { cost = cache[amount - coins[i]]; } else { cost = coin(coins, coinsSize, amount - coins[i], cache); } if (cost Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2020-03-09 00:05:05 "},"computer_system/leetcode/leetcode_week/leetcode_179_week.html":{"url":"computer_system/leetcode/leetcode_week/leetcode_179_week.html","title":"每周一赛-179-week","keywords":"","body":"[leetcode-5354. 通知所有员工所需的时间] 公司里有 n 名员工，每个员工的 ID 都是独一无二的，编号从 0 到 n - 1。公司的总负责人通过 headID 进行标识。在 manager 数组中，每个员工都有一个直属负责人，其中 manager[i] 是第 i 名员工的直属负责人。对于总负责人，manager[headID] = -1。题目保证从属关系可以用树结构显示。公司总负责人想要向公司所有员工通告一条紧急消息。他将会首先通知他的直属下属们，然后由这些下属通知他们的下属，直到所有的员工都得知这条紧急消息。第 i 名员工需要 informTime[i] 分钟来通知它的所有直属下属（也就是说在 informTime[i] 分钟后，他的所有直属下属都可以开始传播这一消息）。返回通知所有员工这一紧急消息所需要的分钟数 。如果员工 i 没有下属，informTime[i] == 0 。 思路上比较常规，采用深度优先搜索，搜索出具有最大通知时间的路径，即所有员工被通知到的最大时间。 深度优先搜索采用递归实现，每次到员工i时，递归通知其所有下属，这里是一个优化点，如何最快的时间找到其所有下属？ 可以遍历所有的节点，判断它的上司是不是i员工； 事先做好保存员工i的所有下属的关系； 对于第一个选择，复杂度较高，会超时;对于第二个选择，如C++/Java/Python等语言都比较容易实现，但是对于C语言来说，不容易实现。同样的问题也会出现在 [leetcode-582. 杀死进程] 中。 这种问题有两种优化方法： 1. 定义数据结构，事先计算每个员工有多少个下属，分配空间后，再遍历保存下属信息； struct node { int child_size; int index; int *childs; }; int inform(int n, int headID, struct node *parents, int *inform_time) { int i = 0; int cost, max_cost = 0; if (inform_time[headID] == 0) { return 0; } for (i = 0; i 2. 用两个数组，一个保存员工i的最后一个孩子，一个保存员工i的上一个兄长。 int inform(int n, int headID, int *last_child, int *sibling, int *inform_time) { int i = 0; int cost, max_cost = 0; if (inform_time[headID] == 0) { return 0; } for (i = last_child[headID]; i >= 0; i = sibling[i]) { cost = inform(n, i, last_child, sibling, inform_time) + inform_time[headID]; max_cost = MAX(max_cost, cost); } return max_cost; } int numOfMinutes(int n, int headID, int* manager, int managerSize, int* informTime, int informTimeSize) { int i; int cost; int *last_child = calloc(1, sizeof(int) * n); int *sibling = calloc(1, sizeof(int) * n); memset(last_child, -1, sizeof(int) * n); for (i = 0; i [leetcode-5355. T秒后青蛙的位置] 给你一棵由 n 个顶点组成的无向树，顶点编号从 1 到 n。青蛙从 顶点 1 开始起跳。规则如下：在一秒内，青蛙从它所在的当前顶点跳到另一个 未访问 过的顶点（如果它们直接相连）。青蛙无法跳回已经访问过的顶点。如果青蛙可以跳到多个不同顶点，那么它跳到其中任意一个顶点上的机率都相同。如果青蛙不能跳到任何未访问过的顶点上，那么它每次跳跃都会停留在原地。 无向树的边用数组 edges 描述，其中 edges[i] = [fromi, toi] 意味着存在一条直接连通 fromi 和 toi 两个顶点的边。返回青蛙在 t 秒后位于目标顶点 target 上的概率。 跟上一题很类似，就是深度优先搜索，但要注意一些细节： 无向树，所有相连的节点都可以认为是孩子 开始节点是1，可以认为它跟-1相连 叶子节点只有跟唯一一个节点相连 如果目标点是叶子节点，那么t >= 0都可以 如果目标点不是叶子节点，那么t == 0才行 我们采用第一种方法，构建结构体来存储孩子节点： struct node { int child_size; int index; int *childs; }; double jump_success(struct node *parents, int from, int start, int t, int target) { int i; double possible = 0.0; /* end */ if (t Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2020-03-09 00:01:52 "},"readings/readings.html":{"url":"readings/readings.html","title":"阅读","keywords":"","body":"养成阅读的习惯 Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 16:30:42 "},"readings/see/reading.html":{"url":"readings/see/reading.html","title":"看见","keywords":"","body":"《看见》 --柴静 别在生活里找你想要的，要去感受生活里发生的东西。 一个了解事物原由的人，才是幸福的。 不要用道德的眼光看待任何问题。 Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 20:07:14 "}}