{"./":{"url":"./","title":"XSystem","keywords":"","body":"XSystem 自2017年毕业后至今已工作两年有余，是该把自己的成长点滴做些记录人生路很长，是一本厚书，此书很大，取名XSystem，致敬逝去的青春和时间 个人能力有限，如有纰漏，望各位看官批评指正。 其中可能会有引用的地方，如有侵权，请联系我删除，联系movetobe@outlook.com 2019.12.10于上海 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2019-12-15 07:51:09 "},"computer_system/computer_sys.html":{"url":"computer_system/computer_sys.html","title":"计算机系统","keywords":"","body":"记录总结成长过程中的计算机技术知识 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 16:18:06 "},"computer_system/深入理解计算机系统/深入理解计算机系统.html":{"url":"computer_system/深入理解计算机系统/深入理解计算机系统.html","title":"深入理解计算机系统","keywords":"","body":"深入理解计算机系统 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:16:02 "},"computer_system/深入理解计算机系统/第一章计算机系统漫游/chapter1.html":{"url":"computer_system/深入理解计算机系统/第一章计算机系统漫游/chapter1.html","title":"第一章 计算机系统漫游","keywords":"","body":"第一章 计算机系统漫游 1. 编译系统 2. 处理器指令操作 3. 进程虚拟内存空间 4. 并发与并行 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:59:22 "},"computer_system/深入理解计算机系统/第一章计算机系统漫游/1-编译系统.html":{"url":"computer_system/深入理解计算机系统/第一章计算机系统漫游/1-编译系统.html","title":"1. 编译系统","keywords":"","body":"编译系统 源程序hello.c -> 预处理器(cpp) -> 修改了的源程序hello.i -> 编译器(ccl) -> 汇编程序hello.s -> 汇编器(as) -> 可重定位目标程序hello.o -> 链接器(ld) -> 可执行目标程序hello 预处理：修改源程序，如#include展开，宏处理等 编译阶段：将文件文件hello.i翻译成hello.s，包含汇编语言程序 汇编阶段：将hello.s翻译成机器语言指令，打包成可重定位目标程序格式，二进制格式 链接阶段：合并可重定位目标程序，即多个.o链接合并成可执行程序 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:24:33 "},"computer_system/深入理解计算机系统/第一章计算机系统漫游/2-处理器指令操作.html":{"url":"computer_system/深入理解计算机系统/第一章计算机系统漫游/2-处理器指令操作.html","title":"2. 处理器指令操作","keywords":"","body":"处理器 处理器核心是一个程序计数器(PC)，其实就是一个寄存器。任何时候，PC都指向主存中的一条机器语言指令。处理器的操作围绕主存、寄存器、算术/逻辑单元(ALU)进行： 加载：从主存中复制一个字节/字道寄存器 存储：从寄存器复制一个字节/字到主存中 操作：两个寄存器中的内容复制到ALU，对这两个数进行操作，并将结果放入一个寄存器中 跳转：从指令中抽取一个字，并将这个字复制到PC中 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:24:40 "},"computer_system/深入理解计算机系统/第一章计算机系统漫游/3-进程虚拟内存空间.html":{"url":"computer_system/深入理解计算机系统/第一章计算机系统漫游/3-进程虚拟内存空间.html","title":"3. 进程虚拟内存空间","keywords":"","body":"Unix进程虚拟内存空间 从低地址往高地址： 只读的代码和数据 可读写数据 堆 共享库内存映射区域 栈 内核虚拟内存 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:24:46 "},"computer_system/深入理解计算机系统/第一章计算机系统漫游/4-并发与并行.html":{"url":"computer_system/深入理解计算机系统/第一章计算机系统漫游/4-并发与并行.html","title":"4. 并发与并行","keywords":"","body":"并发(Concurrency)与并行(Parallelism) 线程级并发 指令级并行 单指令、多数据并行：即SIMD并行，允许一条指令产生多个可以并行执行的操作。 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:24:54 "},"computer_system/深入理解计算机系统/第二章信息的表示和处理/chapter2.html":{"url":"computer_system/深入理解计算机系统/第二章信息的表示和处理/chapter2.html","title":"第二章 信息的表示和处理","keywords":"","body":"第二章 信息的表示和处理 1. 整数的运算 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:57:45 "},"computer_system/深入理解计算机系统/第二章信息的表示和处理/1-整数的运算.html":{"url":"computer_system/深入理解计算机系统/第二章信息的表示和处理/1-整数的运算.html","title":"1. 整数的运算","keywords":"","body":"整数运算 隐式转换 算术运算式中，低类型能够转换为高类型。 赋值表达式中，右边表达式的值自动隐式转换为左边变量的类型，并赋值给他。 函数调用中参数传递时，系统隐式地将实参转换为形参的类型后，赋给形参。 函数有返回值时，系统将隐式地将返回表达式类型转换为返回值类型，赋值给调用函数。 字符必须先转换为整数(C语言规定字符类型数据和整型数据之间可以通用) 。 short型转换为int型(同属于整型) 。 float型数据在运算时一律转换为双精度(double)型，以提高运算精度(同属于实型) 。 低类型 -> 高类型 char/short int unsigned long double ( Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:30:08 "},"computer_system/深入理解计算机系统/第三章程序的机器级表示/chapter3.html":{"url":"computer_system/深入理解计算机系统/第三章程序的机器级表示/chapter3.html","title":"第三章 程序的机器级表示","keywords":"","body":"第三章 程序的机器级表示 1. 操作数(operand) 2. 操作指令 3. 过程 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:59:54 "},"computer_system/深入理解计算机系统/第三章程序的机器级表示/1-操作数.html":{"url":"computer_system/深入理解计算机系统/第三章程序的机器级表示/1-操作数.html","title":"1. 操作数(operand)","keywords":"","body":"操作数指示符 x86-64操作数格式 (AT&T格式汇编) 立即数寻址 格式: $$Imm$ 操作数值: $Imm$ 寄存器寻址 格式: $r_a$ 操作数值: $R[r_a]$ 绝对寻址 格式: $Imm$ 操作数值: $M[Imm]$ 间接寻址 格式: $(r_a)$ 操作数值: $M[R[r_a]]$ (基址 + 偏移量)寻址 格式: $Imm(r_b)$ 操作数值: $M[Imm + R[r_b]]$ 变址寻址 格式: $(r_b, r_i)$ 操作数值: $M[R[r_b] + R[r_i]]$ 格式: $Imm(r_b, r_i)$ 操作数值: $M[Imm + R[r_b] + R[r_i]]$ 比例变址寻址, s必须是1/2/4/8 格式: $(, r_i, s)$ 操作数值: $M[R[r_i] \\cdot s]$ 格式: $Imm(, r_i, s)$ 操作数值: $M[Imm + R[r_i] \\cdot s]$ 格式: $(r_b, r_i, s)$ 操作数值: $M[R[r_b] + R[r_i] \\cdot s]$ 格式: $Imm(r_b, r_i, s)$ 操作数值: $M[Imm + R[r_b] + R[r_i] \\cdot s]$ Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 22:09:49 "},"computer_system/深入理解计算机系统/第三章程序的机器级表示/2-操作指令.html":{"url":"computer_system/深入理解计算机系统/第三章程序的机器级表示/2-操作指令.html","title":"2. 操作指令","keywords":"","body":"操作指令 数据传送指令MOV MOV S, D movb/movw/movl/movq分别传送1/2/4/8字节数据 movabsq传送绝对的8字节 源操作数是一个立即数，存储在寄存器或者内存中 目的操作数要么是寄存器或者内存地址 x86-64要求不能两个操作数都是内存地址，内存-####内存需要两条指令完成 movl指令以寄存器作为目的时，会把该寄存器的高4字节置0 MOVZ S, R 把目的中剩余字节填充0 movzbw/movzbl/movzbq/movzwl/movzwq MOVS S, R 把目的剩余字节填充符号位 movsbw/movsbl/movsbq/movswl/movswq/movslq cltq 将%eax符号拓展到%rax 压栈和弹栈指令 pushq S 将8字节压栈，栈指针保存在$\\%rsp$中 $R[\\%rsp] = R[\\%rsp] - 8$ $M[R[\\%rsp]] = S$ popq D 将8字节出栈 $D = M[R[\\%rsp]]$ $R[\\%rsp] = R[\\%rsp] + 8$ 算术与逻辑指令 leaq S, D 将S的地址加载到D中，即$D = \\&S$ INC D $D = D + 1$ DEC D $D = D - 1$ NEG D $D = -D$ NOT D $D = ~D$ ADD S, D $D = D + S$ SUB S, D $D = D - S$ IMUL S, D $D = D * S$ XOR S, D $D = D ^ S$ OR S, D $D = D | S$ AND S, D $D = D \\& S$ SAL k, D $D = D SHL k, D $D = D SAR k, D $D = D >> k$ 算术右移 SHR k, D $D = D >> k$ 逻辑右移 控制指令 CMP S1, S2 比较S1和S2的值 条件码寄存器：CF(进位标志)/ZF(零标志)/SF(符号标志)/OF(溢出标志) jmp Label 直接跳转 jmp *Operand 间接跳转 je/jz/jne/jnz Label 相等/零 或者 不相等/非零的时候跳转 条件控制转移涉及分支预测，一旦预测失败，影响流水线，进而影响性能。 可以采用条件传送指令 条件控制转移： if (test-express) { then-express; } else { else-express; } 条件传送： v = then-express; ve = else-express; if (!test-express) v = ve; switch语句 switch语句通过跳转表直接跳转到对应的分支上 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 22:12:23 "},"computer_system/深入理解计算机系统/第三章程序的机器级表示/3-过程.html":{"url":"computer_system/深入理解计算机系统/第三章程序的机器级表示/3-过程.html","title":"3. 过程","keywords":"","body":"对抗缓冲区溢出攻击 栈随机化 栈随机化的思想是使栈的位置在程序每次运行时都有变化。 实现原理： 程序开始时，在栈上分配0-n字节之间的随机大小的空间，程序不使用这段空间，但是它会导致程序每次执行时，后续的栈位置发生变化。 分配的范围n必须足够大，才能获得足够多的栈地址变化，又要足够小，不至于浪费程序太多的空间。 Linux中该类技术成为标准，称为地址空间布局随机化(Address-Space Layout Randomization, ASLR)，每次运行时，程序代码/库代码/栈/全局变量/堆数据都会被加载到内存的不同区域。 栈破坏检测 栈保护(stack protector)机制，其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀(canary)值。 金丝雀值是运行时随机产生的，当恢复寄存器状态和从函数返回前，检查金丝雀值是否被改变。 gcc中编译选项-fstack-protector会在相应位置产生金丝雀检查代码，如果检查失败，会执行__stack_chk_fail 限制可执行代码区域 通过限制内存区域的可执行权限，可以消除攻击者在内存区域插入可执行代码的能力。 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:30:57 "},"computer_system/深入理解计算机系统/第四章处理器体系结构/chapter4.html":{"url":"computer_system/深入理解计算机系统/第四章处理器体系结构/chapter4.html","title":"第四章 处理器体系结构","keywords":"","body":"第四章 处理器体系结构 1. 顺序实现 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-18 22:14:32 "},"computer_system/深入理解计算机系统/第四章处理器体系结构/1-顺序实现.html":{"url":"computer_system/深入理解计算机系统/第四章处理器体系结构/1-顺序实现.html","title":"1. 顺序实现","keywords":"","body":"处理器顺序实现 取指(fetch): 从内存读取指令字节，地址为程序计数器(PC)的值 译码(decode): 从寄存器文件读入操作数 执行(execute): 算术/逻辑单元(ALU)要么执行指令指明的操作，计算内存引用的有效地址，要么增加或减少栈指针。 访存(memory): 从内存读出，或者写入 写回(write back): 结果写回寄存器文件 更新PC(PC update): 将PC设置成下一个指令的地址。 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-13 07:08:46 "},"computer_system/深入理解计算机系统/第五章优化程序性能/chapter5.html":{"url":"computer_system/深入理解计算机系统/第五章优化程序性能/chapter5.html","title":"第五章 优化程序性能","keywords":"","body":"Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-19 21:33:04 "},"computer_system/深入理解计算机系统/第五章优化程序性能/1-优化程序性能.html":{"url":"computer_system/深入理解计算机系统/第五章优化程序性能/1-优化程序性能.html","title":"1. 优化程序性能","keywords":"","body":"优化程序性能 消除循环的低效率：即将非必要循环的计算放到循环外，不需要每次循环都进行计算 减少过程调用：即减少不必要的循环内调用 消除不必要的内存引用：减少全局变量的引用，通过局部变量，最后统一赋值全局变量 循环展开 分支预测：尽可能写出对编译器没有歧义的语句，可以帮助编译器优化代码，应该给编译器确定性的代码 性能分析：gprof Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2022-01-03 08:18:36 "},"computer_system/computer_networking/computer_net.html":{"url":"computer_system/computer_networking/computer_net.html","title":"计算机网络","keywords":"","body":"云计算、虚拟化... Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:08:08 "},"computer_system/computer_networking/cloud_networking/cloud_net.html":{"url":"computer_system/computer_networking/cloud_networking/cloud_net.html","title":"云计算网络","keywords":"","body":"云网络 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:08:08 "},"computer_system/computer_networking/cloud_networking/virtio/virtio.html":{"url":"computer_system/computer_networking/cloud_networking/virtio/virtio.html","title":"VIRTIO/VHOST","keywords":"","body":"virtio Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:08:08 "},"computer_system/computer_networking/cloud_networking/virtio/virtio_env.html":{"url":"computer_system/computer_networking/cloud_networking/virtio/virtio_env.html","title":"VIRTIO/VHOST实验环境搭建","keywords":"","body":"OVS+DPDK的VIRTIO后端进行网络端口管理，Libvirt+Qemu+Kvm进行虚拟机管理。 分几步进行搭建： 宿主机(ubuntu20.04)，直接安装ovs+dpdk，安装libvirt+qemu 配置vm-vhostuser-ovsdpdkbr-vhostuser-vm环境 编译、安装ovs+dpdk 搭建环境中碰到的问题 宿主机(ubuntu20.04)，直接安装ovs+dpdk，安装libvirt+qemu 1. 安装ovs+dpdk #apt install dpdk #apt install openvswitch-switch #apt install openvswitch-switch-dpdk 2. 安装libvirt+qemu环境 #apt install virt-manager #apt install libvirt-clients #apt install qemu #apt install qemu-kvm #apt install qemu-system 配置vm-vhostuser-ovsdpdkbr-vhostuser-vm环境 1. 配置大页(默认是2048KB,即2M) 配置大页数量有两种方式： 永久性配置，将大页配置(大页数量)写入配置文件中，机器重启自动配置#echo 'vm.nr_hugepages=4096' > /etc/sysctl.d/hugepages.conf 临时性配置，机器重启后配置丢失，需要重新配置#sysctl -w vm.nr_hugepages=4096 挂载大页 #mount -t hugetlbfs none /dev/hugepages 检查/查看大页相关信息 #cat /proc/meminfo |grep Huge 如果想配置1G大页，按照如下几个步骤配置： 在内核启动项，/boot/grub/grub.cfg中添加，需要重启宿主机default_hugepagesz=1GB hugepagesz=1GB hugepages=4 挂载大页# mount -t hugetlbfs -o pagesize=1G none /dev/hugepages 2. 启动ovs+dpdk 检查ovs版本： #ovs-vsctl show 或者 #ovs-vsctl -V 配置ovs使用用户态数据路径(dpdk) #ovs-vsctl --no-wait set Open_vSwitch . other_config:dpdk-init=true #ovs-vsctl get Open_vSwitch . dpdk_initialized 重启ovs服务 #service openvswitch-switch restart 运行时很多应用的日志都在/var/log/中，所有ovs和libvirt的日志也在/var/log中，如ovs日志： #/var/log/openvswitch/ovs-vswitch.log ovs中添加用户态网桥和vhostuser端口，这里采用的dpdkvhostuserclient类型的端口： #ovs-vsctl add-br ovsdpdkbr0 -- set bridge datapath_type=netdev #ovs-vsctl add-port br0 vhost-user-1 -- set Interface vhost-user-1 type=dpdkvhostuserclient options:vhost-server-path=/tmp/vhost-user-1 #ovs-vsctl add-port br0 vhost-user-2 -- set Interface vhost-user-2 type=dpdkvhostuserclient options:vhost-server-path=/tmp/vhost-user-2 #ovs-vsctl show 3. 配置vm的xml文件(centos-vm1.xml) centos8_vm1 4a9b3f53-fa2a-47f3-a757-dd87720d9d1d 2097152 2097152 1 2048 hvm destroy restart destroy /usr/bin/qemu-system-x86_64 #虚拟机网络连接方式 然后使用virsh管理vm virsh create centos_vm1.xml 可以通过virsh串口进入vm virsh console centos_vm1 也可以通过vnc登录，安装使用VNC Viewer 同理，可以配置并启动vm2。进入vm后，配置对应的IP地址，确认两台vm的通信。至此，通过发行的ovs+dpdk搭建组网，libvirt+qemu+kvm管理vm，搭建简单的vhost实验环境。 编译、安装ovs+dpdk 1. 下载和编译DPDK 本文下载的是DPDK官网的DPDK 19.11.5(LTS)，按照文档编译安装即可。如下为编译脚本： export DPDK_DIR=`pwd` export DPDK_TARGET=x86_64-native-linuxapp-gcc export DPDK_BUILD=$DPDK_DIR/$DPDK_TARGET make install T=$DPDK_TARGET DESTDIR=install 2. 下载和编译OVS 本文下载的是OVS官网的Open vSwitch v2.13.1，按照文档编译安装。如下为编译脚本： DPDK_DIR=\"../../dpdk/dpdk-stable-19.11.5\" DPDK_TARGET=x86_64-native-linuxapp-gcc DPDK_BUILD=$DPDK_DIR/$DPDK_TARGET ./boot.sh ./configure CFLAGS=\"-g -msse4.2 -Wno-cast-align\" --prefix=/usr --localstatedir=/var --sysconfdir=/etc --with-dpdk=$DPDK_BUILD --enable-Werror make make install service openvswitch-switch restart 由于使用ubuntu自带的ovs和dpdk，启动参数使用自带的service来启动。这里编译安装后，直接service重启就可以使用。 搭建环境中碰到的问题 1. 镜像下载(centos) 中国科大镜像 用户名和密码 安装libguestfs-tools#apt install libguestfs-tools 使用工具virt-customize对镜像进行自定义#virt-customize -a centos-vm1.qcow2 --root-password password:your-password 2. 宿主机是否支持虚拟化 安装cpu-checker #apt install cpu-checker 使用命令kvm-ok，如下表示kvm可用 #kvm-ok INFO: /dev/kvm exists KVM acceleration can be used 如果不可用，需要打开硬件虚拟化VT-x/AMD-V。由于我的宿主机是在vbox上运行的ubuntu20.04，直接在vbox该vm的设置->系统->处理器中，选中启用嵌套VT-x/AMD-V的选项，重启机器。如果是服务器，需要在启动项中去打开VT-x/AMD-v。 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:08:08 "},"computer_system/computer_networking/cloud_networking/virtio/virtio_qa.html":{"url":"computer_system/computer_networking/cloud_networking/virtio/virtio_qa.html","title":"VIRTIO/VHOST问题定位","keywords":"","body":" vm-vm正常通信情况下，重启ovs服务后，vm-vm通信终端后未恢复 问题场景： 组网vm1 vhost-user-1 ovsdpdkbr vhost-user-2 vm2 创建vm-vm环境，vm-vm可以正常ping通。 service openvswitch-switch restart vm-vm ping不通 vm1: 193.168.100.100 00:00:00:00:00:01/vm2: 193.168.100.200 00:00:00:00:00:02 问题定位： 1.在vm1设置arp，先让报文从vm1发送出去。在vm1抓包看到发送出去的报文： #tcpdump -i eth1 -xxxxvvvv 可以看到目的MAC，源MAC，源IP，目的IP都是正确的。 2.接着在主机上的vhost端口抓包： #ovs-tcpdump -i vhost-user-1 -xxxxvvvv 可以看到在目的MAC前面多了2个字节的数据，导致整个数据包错位，这样的Ping报文到达vm2，vm2即便接收也无法给出回应。 3.猜测可能与virtio和vhost之间的共享空间存在某种程度的不对齐造成的，具体原因待定位。 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:08:08 "},"computer_system/computer_networking/cloud_networking/SmartNIC/SmartNIC.html":{"url":"computer_system/computer_networking/cloud_networking/SmartNIC/SmartNIC.html","title":"SmartNIC","keywords":"","body":"SmartNIC Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:08:08 "},"computer_system/computer_networking/cloud_networking/SmartNIC/SmartNIC_offload.html":{"url":"computer_system/computer_networking/cloud_networking/SmartNIC/SmartNIC_offload.html","title":"SmartNIC硬件卸载","keywords":"","body":"服务器内虚拟交换方案 早期在服务内虚拟机对外交换的方案是采用虚拟交换的方式，如图所示，通过虚拟交换机与外面进行数据交换。这样存在的问题是数据路径较长，且虚拟交换机是纯软件实现，交换性能受限。即便虚拟交换机数据平面从内核态到用户态的演进，仍然对日益增长的数据流量束手无策。 软硬结合的虚拟交换方案 现在公有云对服务器内虚拟交换的方案，通常采用软硬结合的方案，来提升云网络的交换性能，如图所示。引入智能网卡，通过直通的方式，让虚拟机的虚拟网卡与智能网卡直接数据交互，不再通过虚拟交换机，以达到更高的性能要求。 对于采用软硬结合的虚拟交换方案，通用的有2种实现方案： 采用SRIOV的方案 采用VIRTIO的方案 软硬结合SRIOV方案 SRIOV方案需要在虚拟机内部安装网卡的定制驱动，报文基本流程（vm tx）： vm将报文填入共享内存中 定制化驱动将报文的HPA写入VF的Tx queue中 SmartNIC对HPA地址进行DMA获取报文 SmartNIC对报文与硬件卸载流表进行匹配，匹配成功，报文即从相应端口发送出去 报文没有匹配到硬件卸载流表，上送到OVS OVS进行查表/硬件流表卸载等操作 报文从bond口reinject到网卡发送出去 软硬结合VIRTIO方案 VIRTIO方案采用标准化的virtio-net驱动，vm无需安装额外驱动，virtio-net已随Linux发布，报文基本流程（vm tx）： vm将报文填入共享内存区 virtio后端通过轮询方式知道有报文或者vm发送kick事件通知virtio后端有报文 如果需要virtio后端处理报文，则将vm看到的gpa映射成virtio后端看到的vva，然后进行操作。 如果不需要virtio后端处理报文，则直接将gpa映射成SmartNIC看到的hpa virtio后端将hpa写到SmartNIC VF提供的Tx queue中 SmartNIC 根据hpa地址DMA报文 报文匹配硬件卸载流表，如果匹配上，报文发送成功 报文没有匹配上硬件卸载流表，上送OVS OVS查表/卸载流表到SmartNIC中 报文从bond口reinject到网卡发送出去 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:08:08 "},"computer_system/computer_networking/cloud_networking/SmartNIC/virtio-net.html":{"url":"computer_system/computer_networking/cloud_networking/SmartNIC/virtio-net.html","title":"virtio-net收发报文分析","keywords":"","body":"linux virtio-net收发包分析 virio-net数据结构 Linux内核中关于virtio定义的核心数据结构，也是virtio标准中定义的数据结构 /* Virtio ring descriptors: 16 bytes. These can chain together via \"next\". */ struct vring_desc { /* Address (guest-physical). */ __virtio64 addr; /* Length. */ __virtio32 len; /* The flags as indicated above. */ __virtio16 flags; /* We chain unused descriptors via this, too */ __virtio16 next; }; struct vring_avail { /* The flags as indicated above */ __virtio16 flags; /* Where the driver would put the next descriptor entry in the ring (% queue size) */ __virtio16 idx; __virtio16 ring[]; }; /* u32 is used here for ids for padding reasons. */ struct vring_used_elem { /* Index of start of used descriptor chain. */ __virtio32 id; /* Total length of the descriptor chain which was used (written to) */ __virtio32 len; }; struct vring_used { /* The flags as indicated above */ __virtio16 flags; /* Where the device would put the next descriptor entry in the ring (% queue size) */ __virtio16 idx; struct vring_used_elem ring[]; }; descriptors就是存在报文地址（vm物理地址），该地址指向空间的大小。还有flags标记描述符类型，NEXT表示是一个由多个描述符组成的一个报文，INDIRECT则表示addr不再是指向报文存储的地址，而是另一个描述符的地址。next指针如果有flags为NEXT，就是指向下一个描述符，内核里也用来把没空闲的描述符连接起来。 vm发送报文（vm tx）： available ring就是由virtio-net把要发送的报文的描述符id放入ring[]中，idx表示下一个要放的ring[]的位置。 used ring是virtio-net用来回收已经用过的描述符，也就是virtio-device在从avail ring中读取报文后，会把用完的描述符放入used ring中。 vm接收报文（vm rx）: used ring是virtio-device会把要发送的报文的描述符id放入used ring[]中，virtio-net通过used ring来读取收到的报文。 avail ring是virtio-net把从used ring中读取报文后的描述符放入avail ring中。 virtio-net发送报文 在内核virtio-net实现中，vm发送报文(vm tx) 发送时是从vq->free_head记录的descriptor开始使用，然后对avail ring进行更新，对descriptors进行赋值 virtio-net接收报文 vm接收报文(vm rx) 更新used ring，并将vq->free_head/vq->last_used_idx等信息更新。detach_buf释放descriptor。报文在receive_buf()中处理。 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:08:08 "},"computer_system/computer_networking/cloud_networking/SmartNIC/vhost.html":{"url":"computer_system/computer_networking/cloud_networking/SmartNIC/vhost.html","title":"vhost实现分析","keywords":"","body":"dpdk librte_vhost vhost-user/Qemu之间的消息解析： VHOST_USER_GET_FEATURES：vhost-user收到此消息，需要将自己所支持的特性，用”|”组成u64的值，放在VhostUserMsg里面的u64回复给Qemu，这里面的features包含GSO/GRO等信息 VHOST_USER_SET_FEATURES：vhost-user收到此消息，消息体中带有u64的前端支持的features，前后端都支持的features生效 VHOST_USER_SET_MEM_TABLE: 主要做共享内存的映射 判断nregions是否超过最大值，目前是8片 如果dev->mem已经映射过，判断是否跟之前一致，若一致则关闭每个region的fd 如果映射过，且与之前不一致，则free掉旧的，重新映射 清空iotlb 分配dev->guest_pages在普通堆上 开始填充memory regions：对于每一片内存，一一对应 因此: mmap_addr = mmap(…, (size + mmap_offset), …, fd, …); host_user_addr = mmap_addr + mmap_offset; 如果virtqueue里面的desc/avail/used vring是空，则后面VHOST_USER_SET_VRING_ADDR会做vring地址从qva_to_vva()的转换。 如果virtqueue里面的desc/avalil/used vring非空，就说明之前初始化过，这次memory table更新，需要重新更新virtqueue。 /* Converts QEMU virtual address to Vhost virtual address. */ static uint64_t qva_to_vva(struct virtio_net *dev, uint64_t qva, uint64_t *len) { struct rte_vhost_mem_region *r; uint32_t i; if (unlikely(!dev || !dev->mem)) goto out_error; /* Find the region where the address lives. */ for (i = 0; i mem->nregions; i++) { r = &dev->mem->regions[i]; if (qva >= r->guest_user_addr && qva guest_user_addr + r->size) { if (unlikely(*len > r->guest_user_addr + r->size - qva)) *len = r->guest_user_addr + r->size - qva; return qva - r->guest_user_addr + r->host_user_addr; } } out_error: *len = 0; return 0; } 根据上面从qemu得到的内存信息，更新virtqueue, 需要将qemu发送下来的desc vring/avail vring/used vring的地址通过qva_to_vva()转换成vhost-user看到的地址对于qva_to_vva()也比较好理解，根据qemu传下来的vring地址，和memory regions的地址，找到在哪一片region；然后在region的偏移量offset = qva - guest_user_addr;在vhost-user中看到的地址就是这一片region的起始地址host_user_addr + offset; 至此，VHOST_USER_SET_MEM_TABLE就结束了。 VHOST_USER_SET_VRING_NUM：队列深度，desc数量 VHOST_USER_SET_VRING_ADDR：将qemu空间的desc/avail/used vring的地址转换成vhost-user空间中的virtual memory VHOST_USER_SET_VRING_BASE：qemu告诉vhost-user，avail vring让vhost-user开始使用的位置。index是rx queue or tx queue，num是idx VHOST_USER_SET_VRING_ENABLE：enable队列，同样是使用vhost_vring_state的数据结构,index代表rx queue还是tx queue，num代表enable/disable virtio-device收发报文 virtio-device发送报文(virtio-device -> NIC): available ring就是由virtio-device从avail ring中读取报文描述符，把报文拷贝到mbuf中。used ring就是virtio-device在从avail ring中读取报文后，会把用完的描述符放入used ring中。 virtio-device接收报文(NIC -> virtio-device): avail ring是virtio-device从avail ring中读取可用的描述符。used ring是virtio-device会把要发送的报文从mbuf拷贝到描述符指向的地址中，并将描述符id放入used ring[]中，virtio-net通过used ring来读取收到的报文。 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:08:08 "},"computer_system/virtualization/virt.html":{"url":"computer_system/virtualization/virt.html","title":"虚拟化","keywords":"","body":"虚拟化 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:08:08 "},"computer_system/virtualization/QEMU-KVM/env.html":{"url":"computer_system/virtualization/QEMU-KVM/env.html","title":"QEMU && KVM","keywords":"","body":"QEMU buildroot 非常方便快捷的进行嵌入式Linux操作系统的构建。 https://github.com/buildroot/buildroot Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:08:08 "},"computer_system/virtualization/QEMU-KVM/pci-device.html":{"url":"computer_system/virtualization/QEMU-KVM/pci-device.html","title":"PCI/PCIe设备配置","keywords":"","body":"本文主要总结PCI/PCIe End Point设备的配置，主要从软件的角度，如何配置使用PCI设备。 参考：https://wiki.osdev.org/PCI 设备扫描 首先，软件要扫描所有在PCI配置空间中的设备。 PCI配置空间的起始地址为base_addr，例如QEMU模拟ARM，在hw/arm/virt.c中可以找到VIRT_PCIE_ECAM，对应的基地址是0x3f000000。 对于每个设备的配置，按一定的规则存放在PCI配置空间中。存放规则如下： 也就是说， 对于Bus:Device.Function的PCI设备，它的配置存放在地址base_addr + ((Bus Register Offset要求是4字节对齐。 每个设备配置空间 PCI设备的配置空间有多种格式： Header Type 0x00：普通的PCI Endpoints Header Type 0x01：PCI-to-PCI bridge Header Type 0x02：PCI-to-CardBus bridge 我们这里讨论普通的PCI Endpoints，所以是按照Header Type 0x00的格式来操作每一个PCI设备的配置空间： 读取Vendor ID和Device ID来确定具体的设备。 读取和解析BAR(Base Address Register)空间：读取BAR的0bit，0表示通过内存映射IO（MMIO）的方式操作IO端口，1表示通过IO端口的方式操作IO端口。BAR空间分布如下： 对于QEMU模拟ARM，在hw/arm/virt.c中可以找到VIRT_PCIE_MMIO，对应的地址从0x10000000开始分配，该地址就作为设备与驱动的共享内存空间。分配的大小在设备初始化的时候注册BAR空间时决定。确定设备的地址空间后，将该地址写回BAR字段。 PCI设备其他属性 设置设备的Command命令字段，如disable interrupt/enable interrupt等属性： 可以通过Status状态字段，来查看相关的状态信息： Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:08:08 "},"computer_system/virtualization/QEMU-KVM/pci-device-interrupt.html":{"url":"computer_system/virtualization/QEMU-KVM/pci-device-interrupt.html","title":"QEMU虚拟化PCI设备中断","keywords":"","body":"在QEMU上创建一个虚拟设备的时候，通常需要考虑设备产生中断的方式。当前PCI设备产生中断的方式有传统的PIN脚电平触发中断，还有消息触发的MSI(Message Signaled Interrupts)中断。 本文主要讨论QEMU模拟ARM Cortex-A53环境下，PCI设备电平触发中断，后面有机会再补充MSI/MSIX中断。 在QEMU上创建的PCI设备，通常都挂载在GPEX（Generic PCI Express Bridge）上，传统的中断方式，中断都是通过GPEX上传到GIC（Generic Interrupt Controller），然后到达CPU。这种中断方式是一种共享的中断方式，有中断数目受限、中断处理复杂等缺点。 我们这里想要讨论的是，PCI设备中断触发流程，以及中断到达软件后，中断号是多少的问题。 PCI设备中断触发后到达CPU的中断号 首先，是QEMU的GPIO（General Purpose Input/Output）模型如下： Device.[GPIO_OUT] -> [GPIO_IN].GIC.[GPIO_OUT] -> [GPIO_IN].CPU GIC和CPU会分别创建GPIO_IN，Device和GIC的GPIO_OUT不需要创建，只需要与对应的GPIO_IN做关联 创建设备的时候，要将设备的GPIO_OUT与GIC关联： 4个引脚（#A/#B/#C/#D）对应的中断是irqmap[VIRT_PCIE]，对应到hw/arm/virt.c中的a15irqmap[VIRT_PCIE]的中断范围是3->6。 GIC初始化的时候需要创建GPIO_IN和将GPIO_OUT与CPU做关联: 此时，需要将刚才得出的3->6的中断号转换到全局中断号，全局1->32是CPU私有中断(SPIs和PPIs，所以PCIE的全局中断范围为35->38。 PCI设备中断触发 PCI设备的触发流程，在QEMU中比较成熟，只需要调用qemu_irq_raise()既可以触发中断。 GIC在内核初始化的时候会相应的进行设置，同样在hw/arm/virt.c中，QEMU模拟ARM的GIC Distributor的基地址是0x08000000，GIC CPU的基地址是0x08010000。所以在PCI设备触发中断时，中断一路从gpex送到gic，然后更新GIC->irq_state[irq]的状态，然后一路再调到cpu的generic_handle_interrupt()，设置中断掩码。 CPU在运行中，会检查是否有中断需要处理，根据中断处理的类型，触发CPU的Exception，跳转到Exception Vector Irq Addr去处理，从而进入软件处理流程。 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:08:08 "},"computer_system/data_structure_and_algorithms/algorithms.html":{"url":"computer_system/data_structure_and_algorithms/algorithms.html","title":"数据结构与算法","keywords":"","body":"常见的数据结构与算法知识整理 主要是：数组/字符串/栈/队列/二叉树/图搜索等相关的数据结构下算法的记录 参考代码 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 17:28:23 "},"computer_system/data_structure_and_algorithms/double_pointers/double_pointers.html":{"url":"computer_system/data_structure_and_algorithms/double_pointers/double_pointers.html","title":"双指针","keywords":"","body":"一、双指针 双指针是指使用两个指针对线性数据结构进行遍历/搜索的方法。 双指针方法包括： 首尾指针 快慢指针 前后指针 二、双指针方法解析 首尾指针 首指针从线性表从前往后遍历，尾指针从线性表尾部往前遍历。 [剑指offer-57] 和为s的数字 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得他们的和正好是s。 如果有多对数字的和等于s，则输出任意一对即可。 如：输入数组[1, 2, 4, 7, 11, 15]和数字15，由于4 + 11 = 15，则输出[4, 11]即可 采用首尾指针的双指针方法，如图所示： 若nums[front] + nums[tail] 若nums[front] + nums[tail] > s，则说明nums[tail]太大了，需要减小，故tail--; 若nums[front] + nums[tail] == s，得到解； 结束条件front >= tail，无解 int target_sum(int *nums, int nums_size, int target, int *ret_array) { int front = 0; int tail = nums_size - 1; if ((!nums) || (!ret_array) || (nums_size target) { /* decrease left part */ tail--; } } return (front 对于上述方法，由于最多遍历整个数组的所有元素，故时间复杂度是O(n)。如果数组是没有排序的，且可以改变数组，则可以先qsort()排序，然后再用首尾指针。同理，对于三数之和的题目[leetcode-15], 就可以排序，然后固定一个数，然后就是上述的两数之和了，这样的话，可以在O(n^2) 的时间复杂度内解决。 前后指针 前指针先走k步，然后前后指针同步往后遍历。 [剑指offer-22] 链表中倒数第k个节点 输入一个链表，输出该链表中倒数第k个节点。如1->2->3->4->5->6，则倒数第3个节点 就是4所在的节点。 采用前后指针方法，如图所示： 前指针先走k步 前后指针一起走，直到前指针走到NULL 此时后指针指向的节点就是链表的倒数第k个节点 注意：如果链表长度小于k，该如何处理 struct list_node *find_last_kth_node(struct list_node *head, int k) { int step = 0; struct list_node *before = head; struct list_node *after = head; /* before pointer move k step */ for (step = 0; step next; } /* list length next; after = after->next; } return after; } 从前指针的角度看，前指针从链表头遍历一遍到链表尾，故时间复杂度为O(n)。类似的题目如删除链表倒数第N个节点[leetcode-19]，需要注意的是，删除节点需要另外考虑头节点/中间节点/尾节点删除之后，节点之间指针的变化。 快慢指针 顾名思义，就是双指针中一个指针快一个指针慢，通常都是让快指针一次走2步，慢指针一次走1步。 [剑指offer-23] 链表中环的入口节点 如果链表中包含环，如何找出环的入口节点？如图所示，环的入口点为4的节点。 此问题分为如何判断是否有环？和有环的情况下，如何得到环的入口点。两个子问题。 如何判断有环？这里就要使用快慢指针。我们想象，两个同学以不同的速度，同时从教室跑到操场， 然后开始绕操场跑圈。如果操场是直线的操场，那么跑得快的永远都在前面，直到尽头。如果操场是圆圈的操场，那么跑得慢的同学和跑得快的同学总会相遇，而且肯定是在操场上相遇。回到题目中，我们就可以这样来判断链表中是否有环： 快指针一次走2步，慢指针一次走1步，两个同时从头指针处开始走 如果快指针走到了NULL，那说明没有环 如果快指针与慢指针再次相遇了，说明存在环 struct list_node *list_contain_circle(struct list_node *head) { struct list_node *fast = head; struct list_node *slow = head; /* fast move 2 step each time, slow move 1 step each time */ for (;;) { /* fast pointer will goto NULL, no circle */ if ((fast->next == NULL) || (fast->next->next == NULL)) { return NULL; } fast = fast->next->next; slow = slow->next; /* fast pointer equal to slow, circle * put check after fast and slow update, as fast and slow are both * initialized to head, this is their meet again. */ if (fast == slow) { return fast; } } } 如何得到环的入口点前面我们判断出链表是否存在环，假如存在环，且环的大小是n。那么我们通过前后指针， 让前指针先走n步，然后前后指针一起走，当前后指针相遇的时候就是环的入口点。 这里可以这样理解，你和同学从教室跑去绕操场，你同学一直在领先你一圈的位置。 那么，当你跑到操场入口的时候，你同学在你前面一圈的位置，也就是刚好也在操场入口。 求出环的长度n，只需要从环上一点，开始循环计数，直到回到原点，即得环长度 前指针走n步，前后指针一起走，直到前后指针重叠 返回此时前后指针的节点，即为环的入口点 /* node in the circle can be get from the list_contain_circle interface. */ int list_circle_length(struct list_node *circle_node) { int circle_len = 0; struct list_node *curr = circle_node->next; while (curr != circle_node) { circle_len++; curr = curr->next; } return circle_len + 1; } struct list_node *list_circle_entry(struct list_node *head) { struct list_node *before = head; struct list_node *after = head; struct list_node *node_in_circle = list_contain_circle(head); int circle_len = 0; int step = 0; if (!node_in_circle) { return NULL; } circle_len = list_circle_length(node_in_circle); /* before pointer move circle_len step */ for (step = 0; step next; } /* move together */ while (before != after) { before = before->next; after = after->next; } return before; } 可以看到，在判断是否有环时遍历了一遍链表，在计算环长度遍历了环， 最后查找入口节点时最多可能遍历一边链表。因此，时间复杂度在O(n)量级。 三、总结 在数组中使用双指针，通常需要是排序的数组，因此，对没有排序的数组可以先对数组进行排序。 如前面提到的三数之和的题目[leetcode-15]。数组中双指针进一步可能拓展到多指针，如leetcode-632 最小区间问题。双指针也会用在字符串中，如leetcode-76最小覆盖字串。 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2020-07-21 23:32:46 "},"computer_system/data_structure_and_algorithms/recursive/recursive.html":{"url":"computer_system/data_structure_and_algorithms/recursive/recursive.html","title":"递归/回溯","keywords":"","body":"一、递归 递归通常用在可以把一个问题分解成子问题求解，最终由子问题的解可以合成问题的解。举个例子来理解递归，假如问题的解是[a0, a1, a2, ..., an]，那么用递归求解就是： 求解[a0]和[a1, a2, ..., an]； 求解[a1]和[a2, a3, ..., an]; ... 直到求解出[an]，最后由[a0], [a1], ..., [an]得到最终解。 递归方法优缺点明显。优点： 逻辑清晰，代码简洁。 缺点： 递归层次较深时，函数调用多，性能较差。 递归过程中会重复求解相同的子问题，性能较差。 递归实质上是利用了系统栈的空间，如果层次较深，容易产生栈溢出。 当然，对于重复子问题，可以通过申请一定的空间保存已经计算出来的子问题，从而提高性能。 二、递归应用 递归在线性数据结构、树、图都有应用，涵盖较广。递归应用中通常伴随回溯，当然有时候是不需要回溯的。递归思想上可以用三板斧来思考： 递归结束的条件。 子问题求解。 子问题求解完毕，是否需要回溯。 在实际求解中，可以转换成如下三步： 递归结束的条件。 options，广度上从哪里更进一步？递归函数参数总需要有一个index，来表示走到哪一步？ 是否需要回溯。 线性数据结构中的递归应用 [leetcode-46] 全排队 给定一个没有重复数字的序列，返回其所有可能的全排列。输入: [1,2,3]输出: [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 首先分析题目，全排列数组，就是每次确定一个数，直到最后一个。如上图所示，第一个数可以选择1/2/3中的一个，第二个可以选择剩下的两个中的一个，最后就是剩下的那一个。按上述递归/回溯的思路： 递归结束的条件：最后一个数找到 options，确定这个数有哪些选择？那就是剩下的数里面选一个，然后继续下一个数的选择 回溯，把上次选的数放回去，重新来选 void permute(int *nums, int nums_size, int index, int **return_array, int *return_size) { int i = 0; /* index indicates which step we arrived, ended position: final element */ if (index == nums_size) { return_array[*return_size] = calloc(1, sizeof(int) * nums_size); memcpy(return_array[*return_size], nums, sizeof(int) * nums_size); *return_size = *return_size + 1; return; } /* options: in permutations, what options does current \"index\" can be ? */ for (i = index; i 线性数据结构中使用递归/回溯，如[剑指offer-38]字符串的排列，即输入一个字符串， 输出字符串的所有排列。只是将上述题目中的数字换成字符。还有的题目需要增加每一步是否合法的判断，如[leetcode-47] 数字全排列，需要考虑重复排列，这个就可以对数组先排序，如果current \"index\"跟上一个\"index\"的值一样， 那么意味着重复，需要排除，即在递归前多一个判断这一步是否要走。 [leetcode-22]括号生成， 也是需要增加合法性的判断，即对左括号和右括号个数的判断。 树中的递归应用 树型结构是递归天然的战场。对于树型结构的问题，通常都转化为求解其子树的问题。 树型结构里最经典的就是二叉树，下面我们就以二叉树为例子说明递归/回溯在树型结构中的应用。树型结构递归/回溯常见思路： 递归结束条件：到达叶子节点 options: 左子树和右子树，对于二叉树就这两种选择 回溯，是否需要回溯到父节点 [二叉树的前序/中序/后序遍历] 前序遍历 void preorder(struct tree_node *root) { if (!root) { return; } visit(root->data); preorder(root->left); preorder(root->right); } 中序遍历 void inorder(struct tree_node *root) { if (!root) { return; } inorder(root->left); visit(root->data); inorder(root->right); } 后序遍历 void postorder(struct tree_node *root) { if (!root) { return; } postorder(root->left); postorder(root->right); visit(root->data); } 几乎所有的二叉树的题目都是遍历树，那么就是前序/中序/后序遍历的变形。 图中的递归应用 在图的题目中，最常用的搜索方法就是深度优先搜索(DFS)和广度优先搜索(BFS)。其中， DFS使用递归/回溯方法实现，使得逻辑清晰，代码简洁。 [leetcode-79] 单词搜索 给定一个二维网格和一个单词，找出该单词是否存在于网格中。方向可以上下左右搜素， 网格字符不能重复 仍然是按照前面的三步走： 结束条件：搜索的单词完成了。 options：判断当前字符满足条件，往上下左右走一步。 回溯：上下左右均没有满足，该字符放弃。 int compare_word(char **board, int row, int col, int x, int y, char *word, int index, int **visited) { /* ended position: index is last one */ if (index == (strlen(word))) { return 1; } /* options */ if ((x >= 0) && (x = 0) && (y 三、总结 解题三步走： 结束条件 options：往哪个方向走？ 是否需要回溯？ 子问题优化： 空间换时间，额外空间缓存已经求解的子问题 最后以优化的递归来结束递归/回溯章节 [leetcode-403] 青蛙过河 一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。输入：[0,1,3,5,6,8,12,17]输出：true解释： 总共有8个石子。第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,第三个石子在序号为3的单元格的位置， 以此定义整个数组...最后一个石子处于序号为17的单元格的位置。青蛙可以成功过河：跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着跳2个单位到第4块石子, 然后跳3个单位到第6块石子,跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。 按前面叙述的几个步骤： 结束条件：跳到了最后一个石子 options：跳 k - 1, k, k + 1 三种可能性 不需要回溯，找到就说明存在，没找到就是不存在 优化 如图所示，假设青蛙从index跳k步到next_index，那么只要判断从next_index开始，经过k - 1, k, k + 1步能否到达终点。如果青蛙从index跳k步到达不了next_index，那么到达不了。 重复子问题的优化，只需要用一个二维数组，保存从index跳k步能否到达终点。如果从index跳k步的子问题已经求解过了，则直接返回。否则需要递归求解，求解的结果保存在数组中。 /* cross(stones, stonesSize, 0, 1, cross_hist) */ int cross(int *stones, int stones_size, int index, int step, int **cross_hist) { int stone = stones[index] + step; int next_index = 0; /* ended position: step to last one */ if (stone == stones[stones_size - 1]) { return CROSS_YES; } /* optimize: had been solved */ if (cross_hist[index][step] > CROSS_NONE) { return cross_hist[index][step]; } /* next stone's position, -1 means cannot cross */ next_index = next(stones, stones_size, stone, index); if (next_index Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2020-03-08 23:59:15 "},"computer_system/data_structure_and_algorithms/dynamic_programming/dynamic_programming.html":{"url":"computer_system/data_structure_and_algorithms/dynamic_programming/dynamic_programming.html","title":"动态规划","keywords":"","body":"一、动态规划 对于可以分解成最优子问题的题目，通常可以采用递归求解。而递归一个明显的缺点就是需要求解重复的子问题。对于重复子问题，我们在递归章节采用了缓存的方法来规避。其实，将递归方法采用循环方式实现，加上子问题的缓存，就是动态规划。 二、动态规划应用 动态规划通常用在求解最值问题，如最大值/最小值问题。比较常见的问题在字符串和图中的求解。 字符串中的动态规划 解决两个字符串的动态规划问题，通常可以用两个指针分别指向字符串的最后，然后一步步往前走，缩小问题规模。 最为经典的字符串题目就是求解两个字符串的最长公共子序列。 [leetcode-1143] 最长公共子序列 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，\"ace\" 是 \"abcde\" 的子序列，但 \"aec\" 不是 \"abcde\" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。 类似于数学归纳法的分析方法。我们先讨论字符串text1text1text1从text1[0]→text1[i−1]text1[0] \\rightarrow text1[i - 1]text1[0]→text1[i−1]和字符串text2text2text2从text2[0]→text2[j−1]text2[0] \\rightarrow text2[j - 1]text2[0]→text2[j−1]的最长公共子序列。假设它们的最长公共子序列长度是lcs[i−1][j−1]lcs[i - 1][j - 1]lcs[i−1][j−1]，则我们用归纳法，text1text1text1和text2text2text2都增加一个字符text1[i]text1[i]text1[i]和text2[j]text2[j]text2[j]： 如果text1[i]==text2[j]text1[i] == text2[j]text1[i]==text2[j]，那么lcs[i][j]=lcs[i−1][j−1]+1lcs[i][j] = lcs[i - 1][j- 1] + 1lcs[i][j]=lcs[i−1][j−1]+1 如果text1[i]!=text2[j]text1[i] != text2[j]text1[i]!=text2[j], 则text1[i]text1[i]text1[i]和text2[j]text2[j]text2[j]不可能同时为最长公共子串的字符，只能选择一个作为最长公共子串的字符： 如果text1[i]text1[i]text1[i]作为最长公共子串的一个字符，则lcs[i][j]=lcs[i][j−1]lcs[i][j] = lcs[i][j - 1]lcs[i][j]=lcs[i][j−1] 如果text2[j]text2[j]text2[j]作为最长公共子串的一个字符，则lcs[i][j]=lcs[i−1][j]lcs[i][j] = lcs[i - 1][j]lcs[i][j]=lcs[i−1][j] 那么text1[i]text1[i]text1[i]和text2[j]text2[j]text2[j]选取哪个作为最长公共子串的字符呢？既然我们要找的是最长的，那么对于lcs[i][j−1]lcs[i][j - 1]lcs[i][j−1]和lcs[i−1][j]lcs[i - 1][j]lcs[i−1][j]，我们当然是哪一个大就选哪一个。因此，就得到了最长公共子序列的数学表达式： lcs[i][j]={lcs[i−1][j−1]+1text1[i]==text2[j]max{lcs[i][j−1],lcs[i−1][j]}text1[i]!=text2[j] lcs[i][j] = \\left\\{ \\begin{aligned} & lcs[i - 1][j - 1] + 1 &{text1[i] == text2[j]}\\\\ & max\\{lcs[i][j - 1], lcs[i - 1][j]\\} &{text1[i] != text2[j]} \\end{aligned} \\right. lcs[i][j]={​​​​​lcs[i−1][j−1]+1​max{lcs[i][j−1],lcs[i−1][j]}​​​text1[i]==text2[j]​text1[i]!=text2[j]​​ 为了实现方便，动态规划二维数组下标可以从 1 开始 动态规划还有很重要的一点就是对数据的初始化，因为上述的递推关系，最后都要落到i==0i == 0i==0或者j==0j == 0j==0。通常对于有限的条件下，我们是可以比较容易的得到相应的数据。如上述lcs[i][j]lcs[i][j]lcs[i][j]，当i==0i == 0i==0或者j==0j == 0j==0时，意味着text1text1text1或者text2text2text2为空，那么它们的最长公共子串长度当然是0，即: lcs[0][0] = 0; for (i = 1; i 然后就是对前述递推表达式的实现： for (i = 1; i lcs[i][j - 1] ? lcs[i - 1][j] : lcs[i][j - 1]); } } } 最后只需要取i==strlen(text1)&&j==strlen(text2)i == strlen(text1) \\&\\& j == strlen(text2)i==strlen(text1)&&j==strlen(text2)时的lcs[i][j]lcs[i][j]lcs[i][j]即是text1text1text1和text2text2text2的最长公共子序列的长度值。 int longest_common_subsequence(char *text1, char *text2) { int len1 = strlen(text1); int len2 = strlen(text2); int i, j, longest; int **lcs = calloc(1, sizeof(int *) * (len1 + 1)); for (i = 0; i lcs[i][j - 1] ? lcs[i - 1][j] : lcs[i][j - 1]); } } } longest = lcs[len1][len2]; for (i = 0; i 图中的动态规划 图一般通过二维数组表示，如果其求解的最值问题是单方向增长的，就可以比较容易地想到使用动态规划求解。什么叫做单方向增长呢？比如说，网格上找路径，如果寻找方向只能从左上角->右下角搜索，那么这里就称为单方向增长。如果寻找方向可以上下左右搜索，那么更加适合递归地去搜索。如下面的最短路径和，就是典型的图中动态规划的题目，它的增长方向就是从左上角到右下角。 [leetcode-64]最短路径和 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。如，输入:1,3,11,5,14,2,1输出: 7解释: 因为路径 1->3->1->1->1 的总和最小。 分析方法跟字符串中动态规划的分析方法类似，采用归纳法：假设当前走到了网格中的grid[i][j]grid[i][j]grid[i][j]节点，此时路径上的数字总和最小为ps[i][j]ps[i][j]ps[i][j]，那么： 走到grid[i−1][j]grid[i - 1][j]grid[i−1][j]时，数字总和最小为ps[i−1][j]ps[i - 1][j]ps[i−1][j] 走到grid[i][j−1]grid[i][j - 1]grid[i][j−1]时，数字总和最小为ps[i][j−1]ps[i][j - 1]ps[i][j−1] 显然，因为每个节点只能从两个方向过来，故：ps[i][j]=min{ps[i−1][j],ps[i][j−1]}ps[i][j] = min\\{ps[i - 1][j], ps[i][j - 1]\\}ps[i][j]=min{ps[i−1][j],ps[i][j−1]} 初始化过程： 同样对于i==0i == 0i==0或者j==0j == 0j==0需要做数据初始化。当i==0i == 0i==0或者j==0j == 0j==0时，只有一条路，就是要么向右直走，要么向下直走。故ps[i][0]ps[i][0]ps[i][0]或者ps[0][j]ps[0][j]ps[0][j]初始值就是它们一路的路径之和，即: ps[0][0] = grid[0][0]; for (i = 1; i 然后按上述递推式，完成所有数据： for (i = 1; i 最后所要求取的，就是走到右下角，即ps[i][j]ps[i][j]ps[i][j]的右下角的值。 /* ps[i][j] = min{ps[i - 1][j], p[i][j - 1]} + grid[i][j] */ int min_path_sum(int **grid, int gridSize, int *gridColSize) { int i, j, min_sum; int **ps = calloc(1, sizeof(int *) * gridSize); for (i = 0; i 三、总结 动态规划解答通常分为3步： 递归表达式 初始化数据 循环求解数据 最难的就是递归表达式的描述了。 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2020-01-29 10:34:30 "},"computer_system/data_structure_and_algorithms/mono_stack/mono_stack.html":{"url":"computer_system/data_structure_and_algorithms/mono_stack/mono_stack.html","title":"单调栈","keywords":"","body":"一、什么是单调栈 单调栈是指栈中的数据按递增/递减顺序存放。故单调栈通常分为单调递增栈和单调递减栈。 单调递增栈： 栈中元素按递增顺序存放，通常用于求解数组中比当前元素小的下一个/前一个元素。单调递减栈： 栈中元素按递减顺序存放，通常用于求解数组中比当前元素大的下一个/前一个元素。 二、单调栈的应用 单调栈通常应用在数组中，应用中对于数组中每个元素，核心步骤为(以单调递减栈为例)： 栈非空，当前元素比栈顶大，弹出栈顶元素，开始处理数据。一直弹栈处理，直到栈空，或者比栈顶小。 压栈 (满足单调递减特性) [leetcode-739] 每日温度 根据每日气温列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。如：输入：[73, 74, 75, 71, 69, 72, 76, 73]输出：[1, 1, 4, 2, 1, 1, 0, 0]提示：气温列表长度的范围是 [1, 30000]。气温的值均为华氏度，都是在 [30, 100] 范围内的整数。 如果采用直接求解，则对每个温度，遍历其后的每个元素，判断是否超过该日温度。这样求解的时间复杂度为O(n^2)。这个题目是典型的单调栈的应用，可以在O(n)时间复杂度内求解，不过对应的需要O(n)的空间复杂度。可以采用单调递减栈，对于每日温度，核心步骤为： 栈非空，该日温度比栈顶对应温度大，找到超过栈顶对应温度的第一个温度，弹栈，处理数据。一直弹栈处理，直到栈空，或者该日温度比栈顶对应温度小。 压栈 (栈中温度单调递减，都还没找到比自身大的温度) /* Note: The returned array must be malloced, assume caller calls free(). */ int *dailyTemperatures(int *T, int TSize, int *returnSize) { int *days = calloc(1, sizeof(int) * TSize); int i = 0; struct stack s; int top_day = 0; stack_init(&s); for (i = 0; i top, just pop until current element T[touch_pop(&s)])) { top_day = pop(&s); days[top_day] = i - top_day; } /* push, keep decrease stack */ push(&s, i); } while (!stack_empty(&s)) { days[pop(&s)] = 0; } *returnSize = TSize; return days; } [leetcode-42]接雨水 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,3,1] 表示的高度图，在这种情况下，可以接8个单位的雨水（蓝色部分表示雨水），如：输入: [0,1,0,2,1,0,1,3,2,1,3,1]输出: 8 这个题目也是用单调递减栈来求解，这里为了计算面积的方便，栈中保存的是对应柱子的下标。 可以先只考虑只有一个接雨水的地方，如图中的b->c->d->e之间，那么，从b开始，对于递减的数压栈，则c和B对应的下标相继压栈。接着，碰到比栈顶大的数d，就出现了积水的地方B。此时积水的高度是c和d的低者和栈顶B对应数的差值，而宽度就是d和B下标的差值。因此，我们会弹出栈顶B对应的数，然后去计算积水B，然后d压栈。接着继续e的一系列动作。对于题目中给出的例子，在图中给出了完整的 { 弹(栈)/取(栈顶值)/算/压(栈) } 四个步骤的的过程。 int trap(int *height, int heightSize) { int i = 0; struct stack s; int area = 0; int bottom = 0; int top = 0; int idx_prev = 0; /* decrease stack */ stack_init(&s); for (i = 0; i height[touch_pop(&s)])) { /* pop */ bottom = height[pop(&s)]; if (!stack_empty(&s)) { /* touch top of stack */ idx_prev = touch_pop(&s); top = height[i] 三、总结 单调递减栈： 碰到比栈顶小，压栈；碰到比栈顶大的，弹栈处理。单调递增栈： 碰到比栈顶大，压栈；碰到比栈顶小的，弹栈处理。压栈的元素，可能直接是当前处理的数，也可能是下标。基本上可以用如下框架来完成单调栈(单调递减栈为例)： for (i = 0; i top_of_stack) { pop(); ... } push(); } 一般单调栈的应用需要一定的转换，如[leetcode-1124]表现良好的最长时间段，就是通过转换成前缀和数组后，最后求解前缀和数组的最长上坡。 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2020-01-09 22:21:08 "},"computer_system/data_structure_and_algorithms/tree/tree.html":{"url":"computer_system/data_structure_and_algorithms/tree/tree.html","title":"二叉树","keywords":"","body":"一、二叉树 一直以为树比较简单，因为都是按照左子树/右子树递归来解决问题。但是\b这两天做了leetcode竞赛，其中关于二叉树的题目，不算难，也是按照左子树/右子树递归来解决，但是，在应用实现中，还是有值得思考的地方。 [leetcode-5346]二叉树中的列表 给你一棵以 root 为根的二叉树和一个 head 为第一个节点的链表。 如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 head 为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。 一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。 /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ 根据题目简要分析： 如果head->val == root->val，则只需要判断head->next为首的链表是否存在于root->left为根的左子树或者以root->right为根的右子树中。 否则只需判断head链表是否存在root->left或者root->right的子树中 很容易就可以得到如下简洁清晰的代码： int is_sub_path(struct ListNode* head, struct TreeNode* root){ /* end */ if (!head) { return 1; } if (!root) { return 0; } /* options */ if (head->val == root->val) { if (isSubPath(head->next, root->left) || isSubPath(head->next, root->right)) { return 1; } } if (isSubPath(head, root->left)) { return 1; } if (isSubPath(head, root->right)) { return 1; } return 0; } 很不幸的是，上面代码在leetcode上会超时。如果换一种写法，就能通过。 int sub_path(struct ListNode* head, struct TreeNode* root){ /* end */ if (!head) { return 1; } if (!root) { return 0; } if (head->val != root->val) { return 0; } /* options */ return (sub_path(head->next, root->left) || sub_path(head->next, root->right)); } int is_sub_path(struct ListNode* head, struct TreeNode* root){ /* end */ if (!head) { return 1; } if (!root) { return 0; } /* options */ return (sub_path(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right)); } 惭愧，至写此文时，还没能很好的分析出第二种写法性能好的原因。 [leetcode-1339]分裂二叉树的最大乘积 给你一棵二叉树，它的根为 root 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。 由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。 分为以root'为根的子树，与root树其他部分 root'为根的子树和，递归求解左子树和右子树+root'->val 求解以root'为根的子树与其余部分的乘积 左子树和右子树在递归求解子树和时，对任何一个root''，均会做这三步 这样求解，就从叶子到根，求解以任何一个节点为根的树，与其余部分的乘积 #define MAX(a, b) ((a) > (b) ? (a) : (b)) #define M 1000000007 long sum(struct TreeNode *root) { if (!root) { return 0; } return (root->val + sum(root->left) + sum(root->right)); } long cut(struct TreeNode *root, long *product, long total) { long current_sum; if (!root) { return 0; } current_sum = root->val + cut(root->left, product, total) + cut(root->right, product, total); *product = MAX(*product, (total - current_sum)* current_sum); return current_sum; } int max_product(struct TreeNode* root) { long product = 0; cut(root, &product, sum(root)); return product % M; } Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 16:12:26 "},"computer_system/data_structure_and_algorithms/graph/graph.html":{"url":"computer_system/data_structure_and_algorithms/graph/graph.html","title":"图","keywords":"","body":"一、图搜索 广度优先搜索 层级搜索，故适合求解类似于最短路径/最少等问题。基本方法： 起点入队列 遍历队列，如果需要在最短路径情况的解，需要按层\b遍历，层的\b宽度通过获取当前队列的长度的决定 对该层的所有点，判断其四个方向点是否满足条件，可以入队列 循环2-3步 通常会定义一个cost[i][j]来存储到达(i, j)时的最少消耗/最大\b收益，需要仔细判断什么时候能够更新这个cost[i][j]值，同时将该点入队列 广度优先搜索因为每搜索到一层，就是从\b\b起点到当前层的最短路径，故天然地适合去解决最短路径上问题。很适合去求解路径上需要消除障碍物或者路径上获取最大价值之类的问题。 [leetcode-1293] 网格中的最短路径 给你一个 m x n 的网格，其中每个单元格不是 0（空）就是 1（障碍物）。每一步，您都可以在空白单元格中上、下、左、右移动。如果您 最多 可以消除 k 个障碍物，请找出从左上角 (0, 0) 到右下角 (m-1, n-1) 的最短路径，并返回通过该路径所需的步数。如果找不到这样的路径，则返回 -1。如：输入：grid =[[0,0,0], [1,1,0], [0,0,0], [0,1,1], [0,0,0]],k = 1输出：6 要找最多消除k个障碍物到达目的地 要求最短路径 故采用广度优先搜索，按层\b遍历，每次找到可以往下走的点。 cost[][]保存每个单元格消除障碍物的数量，什么时候能够更新呢？ 当从其他路径可以用消除更少的障碍物，而到达该单元格时需要更新单元格的cost 两种更新场景，更新代表找到了更优的解，需要将当前解入队列： 该单元格有障碍物，cost需要加1 该单元格无障碍物，cost无需增加，就是到达上个节点的cost int cross_obstacles(int **matrix, struct position *start, struct position *end, int k) { int row = end->x + 1, col = end->y + 1; int **cost = calloc(1, sizeof(int *) * row); int **visited = calloc(1, sizeof(int *) * row); int i, j; struct position current, next; struct queue *q = init_queue(); int level_size; struct position directions[] = {% raw %}{{-1, 0}, {0, 1}, {1, 0}, {0, -1}} {% endraw %}; int path_len = 0;; int find = 0; for (i = 0; i x][start->y] = 1; cost[start->x][start->y] = 0; while (queue_size(q) > 0) { level_size = queue_size(q); path_len++; for (i = 0; i x && current.y == end->y) { find = 1; break; } for (j = 0; j = row) || (next.y = col)) { continue; } /* next is not an obstacles */ if ((matrix[next.x][next.y] == 0) && (cost[next.x][next.y] > cost[current.x][current.y])) { cost[next.x][next.y] = cost[current.x][current.y]; if (!visited[next.x][next.y]) { enqueue(q, &next); visited[next.x][next.y] = 1; } } /* next is an obstacles */ if (matrix[next.x][next.y] && (cost[current.x][current.y] + 1 cost[current.x][current.y] + 1)) { /* next cost is greater than from current->next */ cost[next.x][next.y] = cost[current.x][current.y] + 1; if (!visited[next.x][next.y]) { enqueue(q, &next); visited[next.x][next.y] = 1; } } } } if (find) { break; } } for (i = 0; i 类似的题目如[leetcode-5347] 使网格图至少有一条有效路径的最小代价, 此时，由于只需要有效路径，故只需要能让cost变小的路径就应该更新cost。 /* d[i][j] -> d[i + dx][j + dy] update everytime if the value less. */ int min_cost(int **grid, int grid_size, int *grid_col_size) { int i, j; int **cost = calloc(1, sizeof(int *) * gridSize); int **visited = calloc(1, sizeof(int *) * gridSize); struct queue *q = init_queue(); struct position pos = {0, 0}, next; struct position direct[] = {% raw %}{{0, 0}, {0, 1}, {0, -1}, {1, 0}, {-1, 0}} {% endraw %}; int m; for (i = 0; i = gridSize) || (pos.y + direct[i].y = gridColSize[0])) { continue; } next.x = pos.x + direct[i].x; next.y = pos.y + direct[i].y; if ((grid[pos.x][pos.y] == i) && (cost[pos.x][pos.y] 深度优先搜索 二、拓扑排序 实际上，拓扑排序可以看作是 拓扑排序的基本方法： 从图中选取所有入度为0的点，入队列 出队列取值，得到入度为0的点A 遍历所有节点，如果节点的入度为A，删除该节点的入边A，如果删除之后入度为0，则入队列 循环处理2-3，直到所有都处理完，即队列为空 基本框架： void topological_sort(int **graph, int *ingree, int num, int *path) { int i = 0, j = 0; int current; struct queue *q = init_queue(); /* all nodes that ingree == 0 enqueue. */ for (j = 0; j Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2021-12-06 21:08:08 "},"computer_system/leetcode/leetcode.html":{"url":"computer_system/leetcode/leetcode.html","title":"leetcode","keywords":"","body":"参与leetcode活动的相关记录 主要是leetcode每日一题活动/leetcode周竞赛等活动 参考代码 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 17:26:22 "},"computer_system/leetcode/leetcode_everyday/202003.html":{"url":"computer_system/leetcode/leetcode_everyday/202003.html","title":"每日一题-2020/03","keywords":"","body":"2020/03/07 [面试题59 - II. 队列的最大值] 请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的时间复杂度都是O(1)。若队列为空，pop_front 和 max_value 需要返回 -1 有类似的题目是，如何在O(1)时间内获取栈的最小值。类似的思想，采用两个队列，一个存储原始数据，一个存储可能成为下一个最大值的数据，辅助队列为单调递减队列(即保持从front->rear的数据递减)。为什么要保持递减？ 当新来的数据比前面的数据大，毫无疑问，那些比它小的数据都没有用处了。因为在它们出队列之前，最大值永远都是刚来的这个数。 当新来的数据比前面数据小，那么前面的数据都出队列之后，它是有可能成为最大值的。 例子：[3, 4, 4, 3, 5]，主队列A，辅助队列B A: [3], B: [3] A: [3, 4], B: [4] /* B保持从front->rear递减，故3被去掉，4入队列 */ A: [3, 4, 4], B: [4, 4] /* 为判断B何时出队列，B非严格单调递减队列 */ A: [3, 4, 4, 3], B: [4, 4, 3] /* 直接入队列，因为能保持递减 */ A: [3, 4, 4, 3], B: [5] 获取队列最大值就直接从辅助队列的front取值。出队列的时候，如果出队列的值与辅助队列的front位置值相等，辅助队列也要出队列。 具体实现: (push的时候不是O(1)复杂度) struct max_queue { int value[QUEUE_LEN]; int front; int rear; int max_value[QUEUE_LEN]; int max_front; int max_rear; }; int get_queue_max_value(struct max_queue *obj) { return (queue_empty(obj) ? -1 : obj->max_value[obj->max_front]); } void enqueue(struct max_queue *obj, int value) { /* while max_value not empty, keep queue decrease */ while (obj->max_front != obj->max_rear) { obj->max_rear = (obj->max_rear + QUEUE_LEN - 1) % QUEUE_LEN; if (value max_value[obj->max_rear]) { obj->max_rear = (obj->max_rear + 1) % QUEUE_LEN; break; } } obj->max_value[obj->max_rear] = value; obj->max_rear = (obj->max_rear + 1) % QUEUE_LEN; obj->value[obj->rear] = value; obj->rear = (obj->rear + 1) % QUEUE_LEN; } int dequeue(struct max_queue *obj) { int value; if (queue_empty(obj)) { return -1; } value = obj->value[obj->front]; obj->front = (obj->front + 1) % QUEUE_LEN; if (value == obj->max_value[obj->max_front]) { obj->max_front = (obj->max_front + 1) % QUEUE_LEN; } return value; } 2020/03/08 [322. 零钱兑换] 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 常规的深度优先搜索： 明确递减的方向，即amount的值 由于性能问题，需要用cache保存已经计算了的子问题，该子问题就是amount值对应的最少硬币数，即cache[amount]. #define MIN(a, b) ((a) = 0) { cost = cache[amount - coins[i]]; } else { cost = coin(coins, coinsSize, amount - coins[i], cache); } if (cost 2020/03/10 [543. 二叉树的直径] 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。 int longest_path(struct TreeNode *root, int *longest) { int left = 0, right = 0; if (!root) { return 0; } left = longest_path(root->left, longest); right = longest_path(root->right, longest); if (root->left) { left++; } if (root->right) { right++; } *longest = *longest right) ? left : right; } int diameterOfBinaryTree(struct TreeNode* root){ int longest = 0; (void)longest_path(root, &longest); return longest; } Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2020-03-12 08:01:29 "},"computer_system/leetcode/leetcode_week/leetcode_179_week.html":{"url":"computer_system/leetcode/leetcode_week/leetcode_179_week.html","title":"每周一赛-179-week","keywords":"","body":"[leetcode-5354. 通知所有员工所需的时间] 公司里有 n 名员工，每个员工的 ID 都是独一无二的，编号从 0 到 n - 1。公司的总负责人通过 headID 进行标识。在 manager 数组中，每个员工都有一个直属负责人，其中 manager[i] 是第 i 名员工的直属负责人。对于总负责人，manager[headID] = -1。题目保证从属关系可以用树结构显示。公司总负责人想要向公司所有员工通告一条紧急消息。他将会首先通知他的直属下属们，然后由这些下属通知他们的下属，直到所有的员工都得知这条紧急消息。第 i 名员工需要 informTime[i] 分钟来通知它的所有直属下属（也就是说在 informTime[i] 分钟后，他的所有直属下属都可以开始传播这一消息）。返回通知所有员工这一紧急消息所需要的分钟数 。如果员工 i 没有下属，informTime[i] == 0 。 思路上比较常规，采用深度优先搜索，搜索出具有最大通知时间的路径，即所有员工被通知到的最大时间。 深度优先搜索采用递归实现，每次到员工i时，递归通知其所有下属，这里是一个优化点，如何最快的时间找到其所有下属？ 可以遍历所有的节点，判断它的上司是不是i员工； 事先做好保存员工i的所有下属的关系； 对于第一个选择，复杂度较高，会超时;对于第二个选择，如C++/Java/Python等语言都比较容易实现，但是对于C语言来说，不容易实现。同样的问题也会出现在 [leetcode-582. 杀死进程] 中。 这种问题有两种优化方法： 1. 定义数据结构，事先计算每个员工有多少个下属，分配空间后，再遍历保存下属信息； struct node { int child_size; int index; int *childs; }; int inform(int n, int headID, struct node *parents, int *inform_time) { int i = 0; int cost, max_cost = 0; if (inform_time[headID] == 0) { return 0; } for (i = 0; i 2. 用两个数组，一个保存员工i的最后一个孩子，一个保存员工i的上一个兄长。 int inform(int n, int headID, int *last_child, int *sibling, int *inform_time) { int i = 0; int cost, max_cost = 0; if (inform_time[headID] == 0) { return 0; } for (i = last_child[headID]; i >= 0; i = sibling[i]) { cost = inform(n, i, last_child, sibling, inform_time) + inform_time[headID]; max_cost = MAX(max_cost, cost); } return max_cost; } int numOfMinutes(int n, int headID, int* manager, int managerSize, int* informTime, int informTimeSize) { int i; int cost; int *last_child = calloc(1, sizeof(int) * n); int *sibling = calloc(1, sizeof(int) * n); memset(last_child, -1, sizeof(int) * n); for (i = 0; i [leetcode-5355. T秒后青蛙的位置] 给你一棵由 n 个顶点组成的无向树，顶点编号从 1 到 n。青蛙从 顶点 1 开始起跳。规则如下：在一秒内，青蛙从它所在的当前顶点跳到另一个 未访问 过的顶点（如果它们直接相连）。青蛙无法跳回已经访问过的顶点。如果青蛙可以跳到多个不同顶点，那么它跳到其中任意一个顶点上的机率都相同。如果青蛙不能跳到任何未访问过的顶点上，那么它每次跳跃都会停留在原地。 无向树的边用数组 edges 描述，其中 edges[i] = [fromi, toi] 意味着存在一条直接连通 fromi 和 toi 两个顶点的边。返回青蛙在 t 秒后位于目标顶点 target 上的概率。 跟上一题很类似，就是深度优先搜索，但要注意一些细节： 无向树，所有相连的节点都可以认为是孩子 开始节点是1，可以认为它跟-1相连 叶子节点只有跟唯一一个节点相连 如果目标点是叶子节点，那么t >= 0都可以 如果目标点不是叶子节点，那么t == 0才行 我们采用第一种方法，构建结构体来存储孩子节点： struct node { int child_size; int index; int *childs; }; double jump_success(struct node *parents, int from, int start, int t, int target) { int i; double possible = 0.0; /* end */ if (t Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2020-03-09 00:01:52 "},"readings/readings.html":{"url":"readings/readings.html","title":"阅读","keywords":"","body":"养成阅读的习惯 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 16:30:42 "},"readings/see/reading.html":{"url":"readings/see/reading.html","title":"看见","keywords":"","body":"《看见》 --柴静 别在生活里找你想要的，要去感受生活里发生的东西。 一个了解事物原由的人，才是幸福的。 不要用道德的眼光看待任何问题。 《遥远的救世主》 人从根本上只面对两个问题：一是生存，得活下来；二是得回答生命价值的问题，让心有个安住。 神就是道，道就是规律，规律如来，容不得你思议，按规律办事的人就是神。 这就是圆融世故，不显山，不露水，各得其所，可品性这东西，今天缺个角，明天裂个缝，也离塌陷不远了。 人的法则是，一颗阴暗的心，永远托不起一张灿烂的脸。 Copyright © Jason 2019-2021 all right reserved，powered by Gitbook本书发布时间： 2020-07-05 14:58:54 "}}