{"./":{"url":"./","title":"XSystem","keywords":"","body":"XSystem 自2017年毕业后至今已工作两年有余，是该把自己的成长点滴做些记录人生路很长，是一本厚书，此书很大，取名XSystem，致敬逝去的青春和时间 个人能力有限，如有纰漏，望各位看官批评指正。 其中可能会有引用的地方，如有侵权，请联系我删除，联系movetobe@outlook.com 2019.12.10于上海 Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2019-12-15 07:51:09 "},"computer_system/computer_sys.html":{"url":"computer_system/computer_sys.html","title":"计算机系统","keywords":"","body":"Hello CS 常见数据结构算法总结 Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2019-12-30 19:53:22 "},"computer_system/data_structure_and_algorithms/algorithms.html":{"url":"computer_system/data_structure_and_algorithms/algorithms.html","title":"数据结构与算法","keywords":"","body":"常见的数据结构与算法总结 双指针 单调栈 递归/回溯 参考代码 Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2019-12-29 09:14:57 "},"computer_system/data_structure_and_algorithms/double_pointers/double_pointers.html":{"url":"computer_system/data_structure_and_algorithms/double_pointers/double_pointers.html","title":"双指针","keywords":"","body":"一、双指针 双指针是指使用两个指针对线性数据结构进行遍历/搜索的方法。 双指针方法包括： 首尾指针 快慢指针 前后指针 二、双指针方法解析 首尾指针 首指针从线性表从前往后遍历，尾指针从线性表尾部往前遍历。 [剑指offer-57] 和为s的数字 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得他们的和正好是s。 如果有多对数字的和等于s，则输出任意一对即可。 如：输入数组[1, 2, 4, 7, 11, 15]和数字15，由于4 + 11 = 15，则输出[4, 11]即可 采用首尾指针的双指针方法，如图所示： 若nums[front] + nums[tail] 若nums[front] + nums[tail] > s，则说明nums[tail]太大了，需要减小，故tail--; 若nums[front] + nums[tail] == s，得到解； 结束条件front >= tail，无解 int target_sum(int *nums, int nums_size, int target, int *ret_array) { int front = 0; int tail = nums_size - 1; if ((!nums) || (!ret_array) || (nums_size target) { /* decrease left part */ tail--; } } return (front 对于上述方法，由于最多遍历整个数组的所有元素，故时间复杂度是O(n)。如果数组是没有排序的，且可以改变数组，则可以先qsort()排序，然后再用首尾指针。同理，对于三数之和的题目[leetcode-15], 就可以排序，然后固定一个数，然后就是上述的两数之和了，这样的话，可以在O(n^2) 的时间复杂度内解决。 前后指针 前指针先走k步，然后前后指针同步往后遍历。 [剑指offer-22] 链表中倒数第k个节点 输入一个链表，输出该链表中倒数第k个节点。如1->2->3->4->5->6，则倒数第3个节点 就是4所在的节点。 采用前后指针方法，如图所示： 前指针先走k步 前后指针一起走，直到前指针走到NULL 此时后指针指向的节点就是链表的倒数第k个节点 注意：如果链表长度小于k，该如何处理 struct list_node *find_last_kth_node(struct list_node *head, int k) { int step = 0; struct list_node *before = head; struct list_node *after = head; /* before pointer move k step */ for (step = 0; step next; } /* list length next; after = after->next; } return after; } 从前指针的角度看，前指针从链表头遍历一遍到链表尾，故时间复杂度为O(n)。类似的题目如删除链表倒数第N个节点[leetcode-19]，需要注意的是，删除节点需要另外考虑头节点/中间节点/尾节点删除之后，节点之间指针的变化。 快慢指针 顾名思义，就是双指针中一个指针快一个指针慢，通常都是让快指针一次走2步，慢指针一次走1步。 [剑指offer-23] 链表中环的入口节点 如果链表中包含环，如何找出环的入口节点？如图所示，环的入口点为4的节点。 此问题分为如何判断是否有环？和有环的情况下，如何得到环的入口点。两个子问题。 如何判断有环？这里就要使用快慢指针。我们想象，两个同学以不同的速度，同时从教室跑到操场， 然后开始绕操场跑圈。如果操场是直线的操场，那么跑得快的永远都在前面，直到尽头。如果操场是圆圈的操场，那么跑得慢的同学和跑得快的同学总会相遇，而且肯定是在操场上相遇。回到题目中，我们就可以这样来判断链表中是否有环： 快指针一次走2步，慢指针一次走1步，两个同时从头指针处开始走 如果快指针走到了NULL，那说明没有环 如果快指针与慢指针再次相遇了，说明存在环 struct list_node *list_contain_circle(struct list_node *head) { struct list_node *fast = head; struct list_node *slow = head; /* fast move 2 step each time, slow move 1 step each time */ for (;;) { /* fast pointer will goto NULL, no circle */ if ((fast->next == NULL) || (fast->next->next == NULL)) { return NULL; } fast = fast->next->next; slow = slow->next; /* fast pointer equal to slow, circle * put check after fast and slow update, as fast and slow are both * initialized to head, this is their meet again. */ if (fast == slow) { return fast; } } } 如何得到环的入口点前面我们判断出链表是否存在环，假如存在环，且环的大小是n。那么我们通过前后指针， 让前指针先走n步，然后前后指针一起走，当前后指针相遇的时候就是环的入口点。 这里可以这样理解，你和同学从教室跑去绕操场，你同学一直在领先你一圈的位置。 那么，当你跑到操场入口的时候，你同学在你前面一圈的位置，也就是刚好也在操场入口。 求出环的长度n，只需要从环上一点，开始循环计数，直到回到原点，即得环长度 前指针走n步，前后指针一起走，直到前后指针重叠 返回此时前后指针的节点，即为环的入口点 /* node in the circle can be get from the list_contain_circle interface. */ int list_circle_length(struct list_node *circle_node) { int circle_len = 0; struct list_node *curr = circle_node->next; while (curr != circle_node) { circle_len++; curr = curr->next; } return circle_len + 1; } struct list_node *list_circle_entry(struct list_node *head) { struct list_node *before = head; struct list_node *after = head; struct list_node *node_in_circle = list_contain_circle(head); int circle_len = 0; int step = 0; if (!node_in_circle) { return NULL; } circle_len = list_circle_length(node_in_circle); /* before pointer move circle_len step */ for (step = 0; step next; } /* move together */ while (before != after) { before = before->next; after = after->next; } return before; } 可以看到，在判断是否有环时遍历了一遍链表，在计算环长度遍历了环， 最后查找入口节点时最多可能遍历一边链表。因此，时间复杂度在O(n)量级。 三、总结 在数组中使用双指针，通常需要是排序的数组，因此，对没有排序的数组可以先对数组进行排序。 如前面提到的三数之和的题目[leetcode-15]。数组中双指针进一步可能拓展到多指针，如leetcode-632 最小区间问题。双指针也会用在字符串中，如leetcode-76最小覆盖字串。 Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2019-12-17 00:47:04 "},"computer_system/data_structure_and_algorithms/mono_stack/mono_stack.html":{"url":"computer_system/data_structure_and_algorithms/mono_stack/mono_stack.html","title":"单调栈","keywords":"","body":"一、什么是单调栈 二、单调栈的应用 三、总结 Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2019-12-29 09:16:22 "},"computer_system/data_structure_and_algorithms/recursive/recursive.html":{"url":"computer_system/data_structure_and_algorithms/recursive/recursive.html","title":"递归/回溯","keywords":"","body":"一、递归 递归通常用在可以把一个问题分解成子问题求解，最终由子问题的解可以合成问题的解。举个例子来理解递归，假如问题的解是[a0, a1, a2, ..., an]，那么用递归求解就是： 求解[a0]和[a1, a2, ..., an]； 求解[a1]和[a2, a3, ..., an]; ... 直到求解出[an]，最后由[a0], [a1], ..., [an]得到最终解。 递归方法优缺点明显。优点： 逻辑清晰，代码简洁。 缺点： 递归层次较深时，函数调用多，性能较差。 递归过程中会重复求解相同的子问题，性能较差。 递归实质上是利用了系统栈的空间，如果层次较深，容易产生栈溢出。 当然，对于重复子问题，可以通过申请一定的空间保存已经计算出来的子问题，从而提高性能。 二、递归应用 递归在线性数据结构、树、图都有应用，涵盖较广。递归应用中通常伴随回溯，当然有时候是不需要回溯的。递归思想上可以用三板斧来思考： 递归结束的条件。 子问题求解。 子问题求解完毕，是否需要回溯。 在实际求解中，可以转换成如下三步： 递归结束的条件。 options，广度上从哪里更进一步？递归函数参数总需要有一个index，来表示走到哪一步？ 是否需要回溯。 线性数据结构中的递归应用 [leetcode-46] 全排队 给定一个没有重复数字的序列，返回其所有可能的全排列。输入: [1,2,3]输出: [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 首先分析题目，全排列数组，就是每次确定一个数，直到最后一个。如上图所示，第一个数可以选择1/2/3中的一个，第二个可以选择剩下的两个中的一个，最后就是剩下的那一个。按上述递归/回溯的思路： 递归结束的条件：最后一个数找到 options，确定这个数有哪些选择？那就是剩下的数里面选一个，然后继续下一个数的选择 回溯，把上次选的数放回去，重新来选 void permute(int *nums, int nums_size, int index, int **return_array, int *return_size) { int i = 0; /* index indicates which step we arrived, ended position: final element */ if (index == nums_size) { return_array[*return_size] = calloc(1, sizeof(int) * nums_size); memcpy(return_array[*return_size], nums, sizeof(int) * nums_size); *return_size = *return_size + 1; return; } /* options: in permutations, what options does current \"index\" can be ? */ for (i = index; i 线性数据结构中使用递归/回溯，如[剑指offer-38]字符串的排列，即输入一个字符串， 输出字符串的所有排列。只是将上述题目中的数字换成字符。还有的题目需要增加每一步是否合法的判断，如[leetcode-47] 数字全排列，需要考虑重复排列，这个就可以对数组先排序，如果current \"index\"跟上一个\"index\"的值一样， 那么意味着重复，需要排除，即在递归前多一个判断这一步是否要走。 [leetcode-22]括号生成， 也是需要增加合法性的判断，即对左括号和右括号个数的判断。 树中的递归应用 树型结构是递归天然的战场。对于树型结构的问题，通常都转化为求解其子树的问题。 树型结构里最经典的就是二叉树，下面我们就以二叉树为例子说明递归/回溯在树型结构中的应用。树型结构递归/回溯常见思路： 递归结束条件：到达叶子节点 options: 左子树和右子树，对于二叉树就这两种选择 回溯，是否需要回溯到父节点 [二叉树的前序/中序/后序遍历] 前序遍历 void preorder(struct tree_node *root) { if (!root) { return; } visit(root->data); preorder(root->left); preorder(root->right); } 中序遍历 void inorder(struct tree_node *root) { if (!root) { return; } inorder(root->left); visit(root->data); inorder(root->right); } 后序遍历 void postorder(struct tree_node *root) { if (!root) { return; } postorder(root->left); postorder(root->right); visit(root->data); } 几乎所有的二叉树的题目都是遍历树，那么就是前序/中序/后序遍历的变形。 图中的递归应用 在图的题目中，最常用的搜索方法就是深度优先搜索(DFS)和广度优先搜索(BFS)。其中， DFS使用递归/回溯方法实现，使得逻辑清晰，代码简洁。 [leetcode-79] 单词搜索 给定一个二维网格和一个单词，找出该单词是否存在于网格中。方向可以上下左右搜素， 网格字符不能重复 仍然是按照前面的三步走： 结束条件：搜索的单词完成了。 options：判断当前字符满足条件，往上下左右走一步。 回溯：上下左右均没有满足，该字符放弃。 int compare_word(char **board, int row, int col, int x, int y, char *word, int index, int **visited) { /* ended position: index is last one */ if (index == (strlen(word))) { return 1; } /* options */ if ((x >= 0) && (x = 0) && (y 三、总结 三步走： 结束条件 options：往哪个方向走？ 是否需要回溯？ Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2019-12-31 22:44:39 "},"automotive_system/auto_sys.html":{"url":"automotive_system/auto_sys.html","title":"汽车系统","keywords":"","body":"TODO:发展历史和现状就是论文的survey，需要有丰富的行业经验，大量的文献支持。 我才接触AUTOSAR/OSEK OS一段时间，这个survey是着实写不出来，待来日补齐。 智能汽车操作系统历史 智能汽车操作系统行业发展现状 智能汽车操作系统标准 Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2019-12-15 23:24:46 "},"automotive_system/autosar/autosar.html":{"url":"automotive_system/autosar/autosar.html","title":"AUTOSAR标准","keywords":"","body":"Hello AUTOSAR Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2019-12-15 10:32:06 "},"automotive_system/autosar/osek_os/osek.html":{"url":"automotive_system/autosar/osek_os/osek.html","title":"OSEK OS","keywords":"","body":"Hello, OSEK OS Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2019-12-15 23:26:56 "},"automotive_system/autosar/osek_os/task/task.html":{"url":"automotive_system/autosar/osek_os/task/task.html","title":"Task Management","keywords":"","body":"一、Task Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2019-12-31 20:05:33 "}}